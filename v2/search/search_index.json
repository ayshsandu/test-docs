{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to WSO2 Identity Server As an enterprise's applications, services, and API adoptions grow, managing identities (such as employees, vendors, partners, and customers) across internal, shared, and SaaS services becomes a significant challenge. The WSO2 Identity Server is a product that can meet this challenge and also provide options to solve identity problems you may encounter in future. WSO2 Identity Server is fully open source and is released under Apache Software License Version 2.0, one of the most business-friendly licenses available today. WSO2 Identity Server is an identity and access management server that facilitates security, while connecting and managing multiple identities across different applications. It enables enterprise architects and developers to improve customer experience through a secure single sign-on environment. timer Quick Start Try out SSO, MFA, Federation, Self Sign-Up, and Workflows in minutes how_to_reg Authentication Configure Authentication with WSO2 Identity Server call_split Adaptive Authentication Configure Adaptive Authentication with WSO2 Identity Server dynamic_feed Single Sign-On Configure Single Sign-On (SSO) with WSO2 Identity Server cloud_download Identity Federation Configure Federated Authentication with WSO2 Identity Server security Access Control Configure Access Control with WSO2 Identity Server settings_applications APIs Identity and Access Management with APIs settings_input_component Connectors Configure third-party authenticators","title":"Home"},{"location":"get-started/about-this-release/","text":"About this release \u00b6 What is new in this release \u00b6 WSO2 Identity Server 5.9.0 is the latest WSO2 Identity Server release and is the successor of WSO2 Identity Server 5.8.0. It contains the following new features and enhancements: Reusable script library for adaptive authentication : WSO2 Identity Server already supports script-based adaptive authentication. This feature supports easily manageable function libraries that can be imported to the authentication scripts. For more information, see Adaptive Authentication with Function Libraries . New REST APIs : This release includes new REST APIs for end users who can be authenticated to the system to manage their user account related activities. Manage challenge question answers View Authorized OAuth applications and revoke authorization from applications Manage associated accounts View and revoke login sessions Manage pending approvals Manage devices with FIDO2 Manage TOTP URLs and secrets New Configuration model : Configuring WSO2 Identity Server is made easier with a simplified, centralized configuration model that supports injecting configurations with numerous methods such as environment variables, to improve compatibility with various configuration automation tools and cloud native environments. What has changed in this release \u00b6 Removed features and functionalities \u00b6 Logging Monitor UI Deprecated features and functionalities \u00b6 Writing Password Policiy validators Compatible versions \u00b6 For information on the Carbon platform version and Carbon Kernel version of WSO2 Identity Server 5.9.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 . Fixed issues \u00b6 For a complete list of improvements and bug fixes available with this release, see here . Known issues \u00b6 For a complete list of open issues related to the WSO2 Identity Server runtime, see WSO2 IS Runtime - Open Issues . For a complete list of open issues related to the WSO2 Identity Server analytics, see WSO2 IS Analytics - Open Issues","title":"About this Release"},{"location":"get-started/about-this-release/#about-this-release","text":"","title":"About this release"},{"location":"get-started/about-this-release/#what-is-new-in-this-release","text":"WSO2 Identity Server 5.9.0 is the latest WSO2 Identity Server release and is the successor of WSO2 Identity Server 5.8.0. It contains the following new features and enhancements: Reusable script library for adaptive authentication : WSO2 Identity Server already supports script-based adaptive authentication. This feature supports easily manageable function libraries that can be imported to the authentication scripts. For more information, see Adaptive Authentication with Function Libraries . New REST APIs : This release includes new REST APIs for end users who can be authenticated to the system to manage their user account related activities. Manage challenge question answers View Authorized OAuth applications and revoke authorization from applications Manage associated accounts View and revoke login sessions Manage pending approvals Manage devices with FIDO2 Manage TOTP URLs and secrets New Configuration model : Configuring WSO2 Identity Server is made easier with a simplified, centralized configuration model that supports injecting configurations with numerous methods such as environment variables, to improve compatibility with various configuration automation tools and cloud native environments.","title":"What is new in this release"},{"location":"get-started/about-this-release/#what-has-changed-in-this-release","text":"","title":"What has changed in this release"},{"location":"get-started/about-this-release/#removed-features-and-functionalities","text":"Logging Monitor UI","title":"Removed features and functionalities"},{"location":"get-started/about-this-release/#deprecated-features-and-functionalities","text":"Writing Password Policiy validators","title":"Deprecated features and functionalities"},{"location":"get-started/about-this-release/#compatible-versions","text":"For information on the Carbon platform version and Carbon Kernel version of WSO2 Identity Server 5.9.0, see the Release Matrix . All WSO2 products that are based on a specific Carbon Kernel version are expected to be compatible with each other. If you come across any compatibility issue, contact team WSO2 .","title":"Compatible versions"},{"location":"get-started/about-this-release/#fixed-issues","text":"For a complete list of improvements and bug fixes available with this release, see here .","title":"Fixed issues"},{"location":"get-started/about-this-release/#known-issues","text":"For a complete list of open issues related to the WSO2 Identity Server runtime, see WSO2 IS Runtime - Open Issues . For a complete list of open issues related to the WSO2 Identity Server analytics, see WSO2 IS Analytics - Open Issues","title":"Known issues"},{"location":"get-started/access-control-and-entitlement-management/","text":"Access Control and Entitlement Management \u00b6 Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control. Types of access control \u00b6 The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies. Introducing XACML \u00b6 XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website . Why XACML \u00b6 Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note Attribute-based Access Control(ABAC) \u00b6 ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic, in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs. XACML system architecture \u00b6 Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality. XACML terminology \u00b6 The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them. XACML engine architecture \u00b6 The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in <IS_HOME>/repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve ppoliciesolicies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies . Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names: tc:xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names: tc:xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names: tc:xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall, regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.For instance, if the reason for not being able to view a resource is that (a) you are not the owner and (b) you are in the wrong department, we could rework the previous example as follows. When a deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource Policy 1 (permit overrides) Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) Policy 2 Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny. First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources. XACML policy language structure and syntax \u00b6 In order to render an authorization decision, it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP. So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP, where it may form the basic unit of management. Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP, and so it is intended to form the basis of an authorization decision. Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy. As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy. It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: < Target >- This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. < Effect >- The effect of the rule indicates the rule-writer's intended consequence of a \"True\" evaluation of the rule. Two values are allowed: \"Permit\" and \"Deny\". < Condition >- A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target. Therefore, it may be absent. < ObligationExpressions >- Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. < AttributeSelector >- This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: <Policy xmlns=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" PolicyId=\"samplePolicy\" RuleCombiningAlgId=\"urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides\" Version=\"1.0\"> <Target> <AnyOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">read</AttributeValue> <AttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" DataType=\"http://www.w3.org/2001/XMLSchema#string\" MustBePresent=\"true\"/> </Match> </AllOf> </AnyOf> </Target> <Rule Effect=\"Permit\" RuleId=\"permit\"/> </Policy> Improvements in XACML 3.0 \u00b6 The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0. Custom attribute categories \u00b6 Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. <AttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" Category=\"resource\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> Improvements in Obligation \u00b6 In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. <Obligation ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignment AttributeId=\"email\" DataType=\"http://www.w3.org/2001/XMLSchema#string\">user@foo.com</AttributeAssignment> </Obligation> However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). <Obligation ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignment AttributeId=\"text\" DataType=\"http://www.w3.org/2001/XMLSchema#string\">please send email to user</AttributeAssignment> </Obligation> However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to user@foo.com address. <ObligationExpression ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignmentExpression AttributeId=\"email\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeDesignator AttributeId=\"email\" Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\" DataType=\"http://www.w3.org/2001/XMLSchema#string\" MustBePresent=\"false\"/> </AttributeAssignmentExpression> </ObligationExpression> In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set . A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations. Introducing Advice \u00b6 Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision. Improvements in Target \u00b6 Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. <Target> <Resources> <Resource> <ResourceMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo1</AttributeValue> <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ResourceMatch> <ResourceMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo2</AttributeValue> <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ResourceMatch> </Resource> </Resources> <Actions> <Action> <ActionMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar1</AttributeValue> <ActionAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ActionMatch> </Action> <Action> <ActionMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar2</AttributeValue> <ActionAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ActionMatch> </Action> </Actions> </Target> XACML 3.0 has an AND relationship between \u201c foo \u201d resource and bar1 role and an OR relationship between bar2 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. <Target> <AnyOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-regexp-match\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar1</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> </AllOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar2</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> </AllOf> </AnyOf> </Target> More Functions and Algorithms \u00b6 XACML3 has introduced new String functions such as: urn:oasis:names:tc:xacml:3.0:function:string-starts-with urn:oasis:names:tc:xacml:3.0:function:string-ends-with urn:oasis:names:tc:xacml:3.0:function:string-contains urn:oasis:names:tc:xacml:3.0:function:string-substring Some improvements to other functions such as: urn:oasis:names:tc:xacml:3.0:function:dayTimeDuration-equal urn:oasis:names:tc:xacml:3.0:function:yearMonthDuration-equal urn:oasis:names:tc:xacml:3.0:function:dateTime-add-dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny Improvements in XPath \u00b6 New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0. Improvement in XACML Request and Response \u00b6 As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response. XACML 3.0 Multiple Decision Profile \u00b6 This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests . XACML 3.0 JSON Profile \u00b6 This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. Tip WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format . Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The <AttributeValue> element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of <Advice/> and <Obligation/> XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names: tc:xacml:3.0:attribute-category:resource Resource urn:oasis:names: tc:xacml:3.0:attribute-category:action Action urn:oasis:names: tc:xacml:3.0:attribute-category:environment Environment urn:oasis:names: tc:xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names: tc:xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names: tc:xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names: tc:xacml:3.0:attribute-category:codebase Codebase urn:oasis:names: tc:xacml:3.0:attribute-category:requesting-machine RequestingMachine The JSON format supports the fully qualified XACML data-type URI, and also supports the short name of the data-type. \u00b6 XACML data type identifier JSON shorthand type code Mapping/inference rule http://www.w3.org/2001/XMLSchema#string string JSON \"String\" http://www.w3.org/2001/XMLSchema#boolean boolean JSON \"Boolean\" http://www.w3.org/2001/XMLSchema#integer integer JSON \"Number\" without a fractional portion, and within the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#double double JSON \"Number\" with a fractional portion, or out of the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#time time None. Inference must fail. http://www.w3.org/2001/XMLSchema#date date None. Inference must fail. http://www.w3.org/2001/XMLSchema#dateTime dateTime None. Inference must fail. http://www.w3.org/2001/XMLSchema\\#dayTimeDuration dayTimeDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema\\#yearMonthDuration yearMonthDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema\\#anyURI anyURI None. Inference must fail. http://www.w3.org/2001/XMLSchema\\#hexBinary hexBinary None. Inference must fail. http://www.w3.org/2001/XMLSchema\\#base64Binary base64Binary None. Inference must fail. urn:oasis:names: tc:xacml:1.0:data-type:rfc822Name rfc822Name None. Inference must fail. urn:oasis:names: tc:xacml:1.0:data-type:x500Name x500Name None. Inference must fail. urn:oasis:names: tc:xacml:1.0:data-type:ipAddress ipAddress None. Inference must fail. urn:oasis:names: tc:xacml:1.0:data-type:dnsName dnsName None. Inference must fail. urn:oasis:names: tc:xacml:1.0:data-type:xpathExpression xpathExpression None. Inference must fail. xpathExpression data-type values are represented as JSON objects, and each object contains the following properties: Attribute Type Required Default value XPathCategory URI Yes. You can use the short names defined for identifier URIs as values here. None Namespaces Array of namespace declarations No None XPath String Yes None The namespaces property should contain the following properties: Attribute Type Required Default value Prefix String No None Namespace URI Yes None Following is a sample JSON attribute format that contains the fully qualified XACML data-type URI: { \"Attribute\": { \"AttributeId\": \"urn:oasis:names:tc:xacml:3.0:content-selector\", \"DataType\": \"xpathExpression\", \"Value\": { \"XPathCategory\": \"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\", \"Namespaces\": [{ \"Namespace\": \"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" }, { \"Prefix\": \"md\", \"Namespace\": \"urn:example:med:schemas:record\" }], \"XPath\":\"md:record/md:patient/md:patientDoB\" } } } The MultiRequests object is optional in the JSON representation of XACML. The purpose of the MultiRequests object is to support the XACML multiple decision profile. The JSON attribute object contains an array of attribute objects. The attribute object contains the following properties: Property name Type Required Default value AttributeId URI Yes None. The identifier used in the XML representation of a XACML attribute will be used in its JSON representation Value Either string, boolean, number (this maps to either a XACML integer or double as defined in supported data types), object, array of strings, array of boolean, Array of number, array of object, or a mixed array of string and number where the string values represents a numerical value. Yes None. Issuer String No Null Data Type URI No The data type value can be omitted in the JSON representation. The default value is http://www.w3.org/2001/XMLSchema#string . IncludeInResult Boolean No False The results of the JSON request is represented by the decision object in the form of a JSON Object. This can have following properties: Property name Type Required Default value Decision String Yes. Possible values are: Permit, Deny, NotApplicable, Indeterminate None. The results can have the status , obligations , associatedAdvice , category , and policyIdentifierList , which are optional. Following is a sample JSON request that you can try out with WSO2 Identity Server: { \"Request\": { \"AccessSubject\": { \"Attribute\": [ { \"AttributeId\": \"subject-id\", \"Value\": \"sam\", \"DataType\": \"string\", \"IncludeInResult\": true } ] }, \"Resource\": { \"Attribute\": [ { \"AttributeId\": \"resource-id\", \"Value\": \"index.jsp\", \"DataType\": \"string\", \"IncludeInResult\": true } ] }, \"Action\": { \"Attribute\": [{ \"AttributeId\": \"action-id\", \"Value\": \"modify-welcome\", \"DataType\": \"string\", \"IncludeInResult\": true } ] } } } Following is a sample XACML JSON response that you will get for the above request: { \"Response\": [ { \"Decision\": \"Deny\", \"Status\": { \"StatusCode\": { \"Value\": \"urn:oasis:names:tc:xacml:1.0:status:ok\" } }, \"AccessSubject\": { \"Attribute\": [ { \"AttributeId\": \"subject-id\", \"Value\": \"dinali\", \"IncludeInResult\": \"true\", \"DataType\": \"string\" } ] }, \"Resource\": { \"Attribute\": [ { \"AttributeId\": \"resource-id\", \"Value\": \"index.jsp\", \"IncludeInResult\": \"true\", \"DataType\": \"string\" } ] }, \"Action\": { \"Attribute\": [ { \"AttributeId\": \"action-id\", \"Value\": \"modify-welcome\", \"IncludeInResult\": \"true\", \"DataType\": \"string\" } ] } } ] } For a tutorial that demonstrate how WSO2 IS supports fine-grained authorization using XACML requests in JSON format, see Fine-grained Authorization using XACML Requests in JSON Format . Administrative Delegation Profile \u00b6 This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d. XACML 2.0 and XACML 3.0 samples \u00b6 The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: <Request xmlns=\"urn:oasis:names:tc:xacml:2.0:context:schema:os\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd\"> <Subject> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:subject:subject-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeValue>Julius Hibbert</AttributeValue> </Attribute> </Subject> <Resource> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#anyURI\"> <AttributeValue>http://medico.com/record/patient/BartSimpson</AttributeValue> </Attribute> </Resource> <Action> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeValue>read</AttributeValue> </Attribute> </Action> <Environment/> </Request> In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Request xsi:schemaLocation=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd\" ReturnPolicyIdList=\"false\" CombinedDecision=\"false\" xmlns=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:subject:subject-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">Julius Hibbert</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#anyURI\">http://medico.com/record/patient/BartSimpson</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">read</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:environment\" /> </Request> The <Subject> element in XACML 2.0 becomes <Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\"> in XACML 3.0, for example. This is the same for the resource, environment, and action categories.","title":"Access Control and Entitlement Management"},{"location":"get-started/access-control-and-entitlement-management/#access-control-and-entitlement-management","text":"Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control.","title":"Access Control and Entitlement Management"},{"location":"get-started/access-control-and-entitlement-management/#types-of-access-control","text":"The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies.","title":"Types of access control"},{"location":"get-started/access-control-and-entitlement-management/#introducing-xacml","text":"XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website .","title":"Introducing XACML"},{"location":"get-started/access-control-and-entitlement-management/#why-xacml","text":"Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note","title":"Why XACML"},{"location":"get-started/access-control-and-entitlement-management/#attribute-based-access-controlabac","text":"ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic, in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs.","title":"Attribute-based Access Control(ABAC)"},{"location":"get-started/access-control-and-entitlement-management/#xacml-system-architecture","text":"Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality.","title":"XACML system architecture"},{"location":"get-started/access-control-and-entitlement-management/#xacml-terminology","text":"The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them.","title":"XACML terminology"},{"location":"get-started/access-control-and-entitlement-management/#xacml-engine-architecture","text":"The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in <IS_HOME>/repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve ppoliciesolicies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies . Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names: tc:xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names: tc:xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names: tc:xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names: tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names: tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall, regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.For instance, if the reason for not being able to view a resource is that (a) you are not the owner and (b) you are in the wrong department, we could rework the previous example as follows. When a deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource Policy 1 (permit overrides) Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) Policy 2 Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny. First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources.","title":"XACML engine architecture"},{"location":"get-started/access-control-and-entitlement-management/#xacml-policy-language-structure-and-syntax","text":"In order to render an authorization decision, it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP. So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP, where it may form the basic unit of management. Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP, and so it is intended to form the basis of an authorization decision. Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy. As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy. It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: < Target >- This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. < Effect >- The effect of the rule indicates the rule-writer's intended consequence of a \"True\" evaluation of the rule. Two values are allowed: \"Permit\" and \"Deny\". < Condition >- A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target. Therefore, it may be absent. < ObligationExpressions >- Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. < AttributeSelector >- This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: <Policy xmlns=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" PolicyId=\"samplePolicy\" RuleCombiningAlgId=\"urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides\" Version=\"1.0\"> <Target> <AnyOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">read</AttributeValue> <AttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" DataType=\"http://www.w3.org/2001/XMLSchema#string\" MustBePresent=\"true\"/> </Match> </AllOf> </AnyOf> </Target> <Rule Effect=\"Permit\" RuleId=\"permit\"/> </Policy>","title":"XACML policy language structure and syntax"},{"location":"get-started/access-control-and-entitlement-management/#improvements-in-xacml-30","text":"The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0.","title":"Improvements in XACML 3.0"},{"location":"get-started/access-control-and-entitlement-management/#custom-attribute-categories","text":"Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. <AttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" Category=\"resource\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/>","title":"Custom attribute categories"},{"location":"get-started/access-control-and-entitlement-management/#improvements-in-obligation","text":"In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. <Obligation ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignment AttributeId=\"email\" DataType=\"http://www.w3.org/2001/XMLSchema#string\">user@foo.com</AttributeAssignment> </Obligation> However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). <Obligation ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignment AttributeId=\"text\" DataType=\"http://www.w3.org/2001/XMLSchema#string\">please send email to user</AttributeAssignment> </Obligation> However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to user@foo.com address. <ObligationExpression ObligationId=\"send-email\" FulfillOn=\"Deny\"> <AttributeAssignmentExpression AttributeId=\"email\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeDesignator AttributeId=\"email\" Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\" DataType=\"http://www.w3.org/2001/XMLSchema#string\" MustBePresent=\"false\"/> </AttributeAssignmentExpression> </ObligationExpression> In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set . A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations.","title":"Improvements in Obligation"},{"location":"get-started/access-control-and-entitlement-management/#introducing-advice","text":"Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision.","title":"Introducing Advice"},{"location":"get-started/access-control-and-entitlement-management/#improvements-in-target","text":"Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. <Target> <Resources> <Resource> <ResourceMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo1</AttributeValue> <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ResourceMatch> <ResourceMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo2</AttributeValue> <ResourceAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ResourceMatch> </Resource> </Resources> <Actions> <Action> <ActionMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar1</AttributeValue> <ActionAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ActionMatch> </Action> <Action> <ActionMatch MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar2</AttributeValue> <ActionAttributeDesignator AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </ActionMatch> </Action> </Actions> </Target> XACML 3.0 has an AND relationship between \u201c foo \u201d resource and bar1 role and an OR relationship between bar2 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. <Target> <AnyOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-regexp-match\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">foo</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar1</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> </AllOf> <AllOf> <Match MatchId=\"urn:oasis:names:tc:xacml:1.0:function:string-equal\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">bar2</AttributeValue> <AttributeDesignator MustBePresent=\"false\" Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"/> </Match> </AllOf> </AnyOf> </Target>","title":"Improvements in Target"},{"location":"get-started/access-control-and-entitlement-management/#more-functions-and-algorithms","text":"XACML3 has introduced new String functions such as: urn:oasis:names:tc:xacml:3.0:function:string-starts-with urn:oasis:names:tc:xacml:3.0:function:string-ends-with urn:oasis:names:tc:xacml:3.0:function:string-contains urn:oasis:names:tc:xacml:3.0:function:string-substring Some improvements to other functions such as: urn:oasis:names:tc:xacml:3.0:function:dayTimeDuration-equal urn:oasis:names:tc:xacml:3.0:function:yearMonthDuration-equal urn:oasis:names:tc:xacml:3.0:function:dateTime-add-dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny","title":"More Functions and Algorithms"},{"location":"get-started/access-control-and-entitlement-management/#improvements-in-xpath","text":"New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0.","title":"Improvements in XPath"},{"location":"get-started/access-control-and-entitlement-management/#improvement-in-xacml-request-and-response","text":"As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response.","title":"Improvement in XACML Request and Response"},{"location":"get-started/access-control-and-entitlement-management/#xacml-30-multiple-decision-profile","text":"This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests .","title":"XACML 3.0 Multiple Decision Profile"},{"location":"get-started/access-control-and-entitlement-management/#xacml-30-json-profile","text":"This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. Tip WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format . Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The <AttributeValue> element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of <Advice/> and <Obligation/> XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names: tc:xacml:3.0:attribute-category:resource Resource urn:oasis:names: tc:xacml:3.0:attribute-category:action Action urn:oasis:names: tc:xacml:3.0:attribute-category:environment Environment urn:oasis:names: tc:xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names: tc:xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names: tc:xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names: tc:xacml:3.0:attribute-category:codebase Codebase urn:oasis:names: tc:xacml:3.0:attribute-category:requesting-machine RequestingMachine","title":"XACML 3.0 JSON Profile"},{"location":"get-started/access-control-and-entitlement-management/#administrative-delegation-profile","text":"This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d.","title":"Administrative Delegation Profile"},{"location":"get-started/access-control-and-entitlement-management/#xacml-20-and-xacml-30-samples","text":"The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: <Request xmlns=\"urn:oasis:names:tc:xacml:2.0:context:schema:os\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd\"> <Subject> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:subject:subject-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeValue>Julius Hibbert</AttributeValue> </Attribute> </Subject> <Resource> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\" DataType=\"http://www.w3.org/2001/XMLSchema#anyURI\"> <AttributeValue>http://medico.com/record/patient/BartSimpson</AttributeValue> </Attribute> </Resource> <Action> <Attribute AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\" DataType=\"http://www.w3.org/2001/XMLSchema#string\"> <AttributeValue>read</AttributeValue> </Attribute> </Action> <Environment/> </Request> In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Request xsi:schemaLocation=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd\" ReturnPolicyIdList=\"false\" CombinedDecision=\"false\" xmlns=\"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:subject:subject-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">Julius Hibbert</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:resource:resource-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#anyURI\">http://medico.com/record/patient/BartSimpson</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:action\"> <Attribute IncludeInResult=\"false\" AttributeId=\"urn:oasis:names:tc:xacml:1.0:action:action-id\"> <AttributeValue DataType=\"http://www.w3.org/2001/XMLSchema#string\">read</AttributeValue> </Attribute> </Attributes> <Attributes Category=\"urn:oasis:names:tc:xacml:3.0:attribute-category:environment\" /> </Request> The <Subject> element in XACML 2.0 becomes <Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\"> in XACML 3.0, for example. This is the same for the resource, environment, and action categories.","title":"XACML 2.0 and XACML 3.0 samples"},{"location":"get-started/architecture/","text":"Architecture \u00b6 WSO2 Identity Server (WSO2 IS) is a product built on top of WSO2 Carbon. Based on the OSGi specification, it enables easy customization and extension through its componentized architecture. This topic describes the architecture of the Identity Server. The users are given the choice of deployment to on-premise servers, private cloud or public cloud without configuration changes. WSO2 Identity Server is used directly by multiple users, through its user-friendly Management Console . Apart from the default admin user (with the user name \u2018admin\u2019), other users can be created later by the admin users that have the privileges to create a new user, or by signing up. Each user can have roles, where each role can have privileges assigned to them. A user\u2019s roles can be changed at any time by the admin user. Apart from such registered users, Identity Server is also used as an identity provider for third party applications, which also have their own sets of users. Architecture and process flow \u00b6 The following diagram depicts the architecture of the Identity Server and the various processes that take place within it. Watch the following video for a quick overview of the process flow of the Identity Server architecture and how the various components interact with each other. Authentication framework \u00b6 The following are the authenticator types in the authentication framework. Inbound authenticators \u00b6 The responsibility of inbound authenticators is to identify and parse all the incoming authentication requests and then build the corresponding response. A given inbound authenticator has two parts. Request Processor Response Builder For each protocol supported by WSO2 Identity Server, there should be an inbound authenticator. This architecture component includes inbound authenticators for Security Assertion Markup Language (SAML) 2.0 , OpenID Connect , OAuth 2.0 , and WS-Federation (passive) . In other words, the responsibility of the SAML 2.0 request processor is to accept a SAML request from a service provider, validate the SAML request and then build a common object model understood by the authentication framework and handover the request to it. The responsibility of the SAML response builder is to accept a common object model from the authentication framework and build a SAML response out of it. Both the request processors and the response builders are protocol aware, while the authentication framework is not coupled to any protocol. Local authenticators \u00b6 The responsibility of the local authenticators is to authenticate the user with locally available credentials. This can be either user name /password or even IWA (Integrated Windows Authentication) . Local authenticators are decoupled from the Inbound Authenticators. Once the initial request is handed over to the authentication framework from an inbound authenticator, the authentication framework talks to the service provider configuration component to find the set of local authenticators registered with the service provider corresponding to the current authentication request. Once the local authentication is successfully completed, the local authenticator will notify the framework. The framework will now decide no more authentication is needed and hand over the control to the corresponding response builder of the inbound authenticator. You can develop your own local authenticators and plug them into the Identity Server. Outbound/federated authenticators \u00b6 The responsibility of the federated authenticators is to authenticate the user with an external system. This can be with Facebook, Google, Yahoo, LinkedIn, Twitter, Salesforce or any other identity provider. Federated authenticators are decoupled from the Inbound Authenticators. Once the initial request is handed over to the authentication framework from an inbound authenticator, the authentication framework talks to the service provider configuration component to find the set of federated authenticators registered with the service provider corresponding to the current authentication request. A federated authenticator has no value unless it is associated with an identity provider. The Identity Server out-of-the-box supports Security Assertion Markup Language (SAML) 2.0, OpenID Connect, OAuth 2.0, and WS-Federation (passive). The SAML 2 .0 federated authenticator itself has no value. It has to be associated with an Identity Provider. Google Apps can be an identity provider - with the SAML 2.0 federated authenticator. This federated authenticator knows how to generate a SAML request to the Google Apps and process a SAML response from it. There are two parts in a federated authenticator. Request Builder Response Processor Once the federation authentication is successfully completed, the federated authenticator will notify the authentication framework. The framework will now decide no more authentication is needed and hand over the control to the corresponding response builder of the inbound authenticator. Both the request builder and the response processor are protocol aware while the authentication framework is not coupled to any protocol. You can develop your own federated authenticators and plug them into the Identity Server. Multi-option authenticators \u00b6 The service provider can define how to authenticate users at the Identity Server, for authentication requests initiated by it. While doing that, each service provider can pick more than one authenticator to allow end users to get multiple login options. This can be a combination of local authenticators and federated authenticators. Multi-factor authenticators \u00b6 The service provider can define how to authenticate users at the Identity Server, for authentication requests initiated by it. While doing that, each service provider can define multiple steps and for each step it can pick more than one authenticator. The authentication framework tracks all the authenticators in each step and proceeds to the next step only if the user authenticates successfully in the current step. It is an AND between steps, while it is an OR between the authenticators in a given step. Provisioning framework \u00b6 The following are the provisioning components available in the provisioning framework. Inbound provisioning \u00b6 Inbound provisioning focuses on how to provision users to the Identity Server. Out-of-the-box, the Identity Server supports inbound provisioning via a Simple Object Access Protocol ( SOAP) based API as well as the System for Cross-domain Identity Management ( SCIM) 1.1 API. Both the APIs support HTTP Basic Authentication. If you invoke the provisioning API with Basic Authentication credentials, then where to provision the user (to which user store) will be decided based on the inbound provisioning configuration of the resident service provider. The SCIM API also supports OAuth 2.0. If the user authenticates to the SCIM API with OAuth credentials, then the system will load the configuration corresponding to the service provider who owns the OAuth client id. If you plan to invoke the SCIM API via a web application or a mobile application, we would highly recommend you to use OAuth instead of Basic Authentication. You simply need to register your application as a service provider in Identity Server and then generate OAuth keys. Just-in-time provisioning \u00b6 Just-in-time (JIT) provisioning talks about how to provision users to the Identity Server at the time of federated authentication. A service provider initiates the authentication request, the user gets redirected to the Identity Server and then Identity Server redirects the user to an external identity provider for authentication. Just-in-time provisioning gets triggered in such a scenario when the Identity Server receives a positive authentication response from the external identity provider. The Identity Server will provision the user to its internal user store with the user claims from the authentication response. You configure JIT provisioning against an identity provider - not against service providers. Whenever you associate an identity provider with a service provider for outbound authentication, if the JIT provisioning is enabled for that particular identity provider, then the users from the external identity provider will be provisioned into the Identity Server's internal user store. In the JIT provisioning configuration you can also pick the provisioning user store. JIT provisioning happens while in the middle of an authentication flow. The provisioning can happen in a blocking mode or in a non-blocking mode. In the blocking mode, the authentication flow will be blocked till the provisioning finishes - while in the non-blocking mode, provisioning happens in a different thread. Outbound provisioning \u00b6 Outbound provisioning talks about provisioning users to external systems. This can be initiated by any of the following. Inbound provisioning request (initiated by a service provider or the resident service provider) JIT provisioning (initiated by a service provider) Adding a user via the management console (initiated by the resident service provider) Assigning a user to a provisioning role (initiated by the resident service provider) WSO2 Identity Server supports outbound provisioning with the following connectors. You need to configure one or more outbound provisioning connectors with a given identity provider, and associate the identity provider with a service provider. All the provisioning requests must be initiated by a service provider - and will be provisioned to all the identity providers configured in the outbound provisioning configuration of the corresponding service provider. SCIM SPML SOAP Google Apps provisioning API Salesforce provisioning API Components of the architecture \u00b6 The following table lists out the components pertaining to the architecture of the WSO2 Identity Server, which are depicted in the above figure and video. Component Description Process flow Service providers A Service Provider (SP) is an entity that provides Web services. A service provider relies on a trusted Identity Provider (IdP) for authentication and authorization. In this case, the Identity Server acts as the IdP and does the task of authenticating and authorizing the user of the service provider. Salesforce and Google Apps are examples of service providers and are used as such in this case. Related Links For information on how to add a service provider to the Identity Server, and do the necessary configurations to integrate the SP with the Identity Server, see Adding and Configuring a Service Provider . A user of the service provider (SP) attempts to log into the SPs application. The service provider sends an authentication request to the Identity Server. This request is met by the Inbound Authentication component of the Identity Server and comes in one of the following forms. SAML SSO OAuth/OpenID Connect Passive STS The service provider receives the authentication confirmation from the Identity Server once it follows all the specified processes required in order to authenticate the SP's user. Additionally, if a user registers in the service provider's application, a Simple Object Access Protocol ( SOAP) or System for Cross-domain Identity Management ( SCIM) request can be sent to the Identity Server. The request is met by the Inbound Provisioning component of the Identity Server. Inbound authentication The Inbound Authentication component of the Identity Server can handle any of the following requests. SAML SSO : Security Assertion Markup Language (SAML) is an OASIS open standard for representing and exchanging user identity and authentication data between parties. SAML provides the web-based Single-Sign-On capability. WSO2 IS supports SAML 2.0. OAuth/OpenID Connect : OAuth 2.0 has three main phases. They are; requesting an Authorization Grant, exchanging the Authorization Grant for an Access Token and accessing the resources using this Access Token. OpenID Connect is another identity layer on top of OAuth 2.0. OAuth applications can get authentication event information over the ID token and can get the extra claims of the authenticated user from the OpenID Connect UserInfo endpoint. WSO2 IS supports Oauth 1.0 and 2.0. Passive STS : A Security Token Service (STS) is a software based identity provider responsible for issuing security tokens, especially software tokens, as part of a claims-based identity system. Related Links For information on how to configure inbound authentication, see Configuring Inbound Authentication for a Service Provider . The inbound authentication component of the Identity Server receives the authentication request from the service provider. You can configure the Identity Server to receive either SAML SSO, OAuth/OpenID Connect, or WS-Federation requests. Your configuration depends on the service provider in question. Once the conditions are met in the inbound authentication component, the request is sent on to the authentication framework. Once the request is acted upon, a response from the OUT channel of the authentication framework is received by the inbound authentication component . This response is sent back to the service provider. Authentication framework Claim management is a key aspect of the Identity Server, which helps to map local claims to service provider claims and vice versa. It also enables you to map local claims to identity provider claims and vice versa. Just-in-Time (JIT) provisioning allows you to create users on the fly without having to create user accounts in advance. For example, if you recently added a user to your application, you don't need to manually create the user in the Identity Server. When they log in with single sign-on, their account is automatically created for them, eliminating the time and effort related to creating the account. Just-in-Time provisioning works with your identity provider to pass the correct user information to the Identity Server. Related Links For information on mapping local claims and service provider claims, see Configuring Claims for a Service Provider . For mapping local claims and identity provider claims, see Configuring Claims for an Identity Provider . For information on configuring Just-in-Time provisioning, see Configuring Just-In-Time Provisioning for an Identity Provider . The inbound authentication component sends the authentication request to the IN channel of the authentication framework. Here claim mapping is checked based on the configurations. Once this is done, the authentication request is sent onwards to either the local authenticators, the federated authenticators or both. Once the authentication is complete, a response is sent from the local and/or federated authenticators to the OUT channel of the authentication framework. The authentication framework handles mapping local claims to the IdP as required. Then the JIT provisioning component within the authentication framework sends this on to the provisioning framework. Once the request is acted upon, a response is sent from the OUT channel of the authentication framework back to the inbound authentication. Local authenticators Local authenticators are authentication processes available within the Identity Server itself. User name /password authentication happens by authenticating the credentials entered against the values in the user store connected to the Identity Server. Related Links For more information on how to configure local authenticators in the Identity Server, See Configuring Local and Outbound Authentication for a Service Provider . For more information about windows-based authentication, see Integrated Windows Authentication . The IN channel of the authentication framework sends the authentication request to the local authenticators component. The local authenticator does the authentication by checking the user name and password or by using Integrated Windows Authentication (IWA) . Once this is authentication is done, it provides the authentication response to the OUT channel of the authentication framework. Federated authenticators Federated authenticators are authentication processes that are not available within the Identity Server. These need to be configured to reach out to external applications to do the authentication process and send the response back to the Identity Server. Related Links For more information on how to configure federated authenticators with the various identity providers, see Configuring Federated Authentication . The IN channel of the authentication framework sends the authentication request to the federated authenticators component. The federated authenticators do the authentication by checking the authentication request in the specified authenticator. For example, if Facebook is configured, the authentication process will reflect that. Once this authentication is done, it provides the authentication response to the OUT channel of the authentication framework. Identity providers Identity providers perform authentication. To receive authentication requests from the Identity Server, configurations need to be done at the identity provider side as well . Identity providers are also known as external applications. The protocol specific authenticators (SAML2, OpenID Connect, WS-Federation (Passive)) represent applications that use these protocols for authentication requests. The authentication request comes in from the federated authenticators component and is sent to the relevant identity provider (External application). The user is authenticated and logged in to the relevant external application. A single authentication request can require authentication from multiple external applications. Provisioning framework The provisioning framework is responsible for all provisioning work done by the Identity Server. This framework integrates with the User Store Manager component and also receives provisioning requests from the authentication framework. The JIT provisioning component of the OUT channel in the authentication framework sends on the request to the provisioning framework. This occurs if the user is not added into the user store and needs to be added in on-the-fly. The provisioning framework sends the user details to the user store manager and the user is added. Once the user is added, the user store manager contacts the provisioning framework with the response. The SCIM and SOAP requests that arrive from the service provider are added to the user store manager. This information is also sent on the provisioning framework. The provisioning framework sends this along to the outbound provisioning component. Authorization manager WSO2 Identity Server contains an advanced entitlement auditing and management. It provides entitlement management for any REST or SOAP calls. WSO2 Identity Server provides attribute and claim-based access control via XACML, WS-Trust, OpenID Connect and claim management. WSO2 Identity Server also provides role-based access control (RBAC) and fine-grained policy-based access control via XACML. WSO2 Identity Server provides a friendly user interface for policy editing. It also supports multiple Policy Information Point (PIP) and policy distribution to various Policy Decision Points (PDPs). It provides a high-performance network protocol (over Thrift) for PEP/PDP interaction, and policy decision and attribute caching. Notifications are provided for policy updates. Moreover, the WSO2 Carbon TryIt tool that comes bundled with the Identity Server lets the user explore the policy impact. Related Links For more information on how to use and manage entitlement within the Identity Server, see Working with Entitlement . Authorization does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. This is primarily a functionality that can be managed using APIs that are written to perform authorization tasks. IdP and SP configurations The identity provider and service provider configurations provide the basis for all actions that happen within the authentication framework and provisioning framework. Related Links For more information on how to configure the service provider, see Adding and Configuring a Service Provider . For more information on how to configure the identity provider, see Adding and Configuring an Identity Provider . The identity provider and service provider configurations go to both the authentication framework and provisioning framework. Inbound provisioning Inbound provisioning requests can come in the form of SCIM or SOAP. The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in the WSO2 Identity Server easier. Identity provisioning is a key aspect of any Identity Management Solution. In simple terms, it is to create, maintain and delete user accounts and related identities in one or more systems or applications in response to business processes which are initiated either by humans directly or by automated tasks. Simple Object Access Protocol (SOAP) is a protocol for exchanging XML-based messages over a network, normally using HTTP. SOAP forms the foundation layer of the Web services stack, providing a basic messaging framework that more abstract layers can build on. SOAP services are defined using Web Services Definition Language (WSDL) and are accessible using a URL that is known as a SOAP endpoint. Here, a SOAP API is used to provision users to the Identity Server. Related Links For more information on configuring inbound provisioning, see Configuring Inbound Provisioning for a Service Provider . The SCIM or SOAP request comes into the inbound provisioning component from the service provider. The inbound provisioning component receives this request, processes it based on the configurations and sends the request on to the user store manager. User store manager WSO2 Identity Server implements flexible user store via built-in LDAP (powered by ApacheDS), external LDAP, Microsoft Active Directory or any JDBC database. It provides an API for integrating identity management to any application. WSO2 Identity Server allows tenants/organizations to configure their user stores through the admin console. WSO2 Identity Server supports multiple profiles per user using its flexible profile management feature. Related Links For more information, see User Management Architecture For more information on how to configure user stores, see Configuring the Realm . For more information on how to work with users and roles, see Configuring Users, Roles and Permissions . The user store manager receives provisioning requests from the provisioning framework. These provisioning requests are handled and the relevant user store is updated. The request can affect multiple user stores if the configuration is such. Once this request has been handled, an update is sent back to the provisioning framework. The inbound provisioning component sends SCIM and SOAP provisioning requests on to the user store manager. The user store manager receives the provisioning request, acts on it and sends it on to the provisioning framework where it has to be sent on for outbound provisioning. Claim manager A claim is a piece of information about a particular subject. It can be anything that the subject is owned by or associated with, such as name, group, preferences, etc. A claim provides a single and general notion to define the identity information related to the subject. Claim-based identity is a common way for any application to acquire the identity information. It provides a consistent approach for all applications by hiding the lower level implementation. Claims are also used in identity propagation, by packaging the claims into one or more tokens (such as SAML). These tokens are then issued by an issuer; commonly known as a security token service (STS). Related Links For more information on managing claims, see Claim Management For information on how to configure claims on the service provider side, see Configuring Claims for a Service Provider For information on how to configure claims on the identity provider side, See Configuring Claims for an Identity Provider . Claim management does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. Primarily, it integrates with the following four components. Authentication framework Authorization manager Provisioning framework User store manager XACML eXtensible Access Control Markup Language ( XACML) is ideally a part of the authorization manager component but it is depicted separately due to its unique role in the Identity Server architecture. XACML is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that enable it to surpass being just a fine grain authorization mechanism. XACML describes access control policy language, request/response language and reference architecture. The policy language is used to express access control policies (who can do what when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). eXtensible Access Control Markup Language ( XACML) does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. Auditing WSO2 Identity Server supports auditing of privileged operations using distributed auditing system (XDAS). It also allows you to monitor and collect standard access and performance statistics. The Analytics component of WSO2 Identity Server supports monitoring session and authentication statistics. Auditing does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. IS can be configured to produce audit logs for all of its components but the following components are most commonly used for logging details. Authentication framework Provisioning framework User store manager Identity manager Enterprise IT Systems are constantly changing; their perimeters are expanding and their policies keep changing. Therefore, in such a rapidly evolving world, security solutions need to be forward thinking and innovative. They need to be configurable in order to keep pace and adapt to rapid changes. This can be achieved by the identity manager component because it caters to security requirements at hand as well as looking toward the future. It has a very customizable user interface and can be easily implemented in order to ensure maximum security for your system. Identity manager does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server, primarily the user store manager. Outbound provisioning The Outbound Provisioning component of the Identity Server can send provisioning requests to applications that support the following connectors. SCIM SPML Google Salesforce These connectors reach out to identity providers that perform the provisioning. Related Links For more information on how to configure outbound provisioning connectors, see Configuring Outbound Provisioning Connectors for an Identity Provider . The provisioning request comes into the outbound provisioning component from the provisioning framework. This request will go to the relevant connector. Related Links For further reading about the architecture in an Identity and Access Management solution, see the following article: Identity Architect Ground Rules: Ten IAM Design Principles .","title":"Architecture"},{"location":"get-started/architecture/#architecture","text":"WSO2 Identity Server (WSO2 IS) is a product built on top of WSO2 Carbon. Based on the OSGi specification, it enables easy customization and extension through its componentized architecture. This topic describes the architecture of the Identity Server. The users are given the choice of deployment to on-premise servers, private cloud or public cloud without configuration changes. WSO2 Identity Server is used directly by multiple users, through its user-friendly Management Console . Apart from the default admin user (with the user name \u2018admin\u2019), other users can be created later by the admin users that have the privileges to create a new user, or by signing up. Each user can have roles, where each role can have privileges assigned to them. A user\u2019s roles can be changed at any time by the admin user. Apart from such registered users, Identity Server is also used as an identity provider for third party applications, which also have their own sets of users.","title":"Architecture"},{"location":"get-started/architecture/#architecture-and-process-flow","text":"The following diagram depicts the architecture of the Identity Server and the various processes that take place within it. Watch the following video for a quick overview of the process flow of the Identity Server architecture and how the various components interact with each other.","title":"Architecture and process flow"},{"location":"get-started/architecture/#authentication-framework","text":"The following are the authenticator types in the authentication framework.","title":"Authentication framework"},{"location":"get-started/architecture/#inbound-authenticators","text":"The responsibility of inbound authenticators is to identify and parse all the incoming authentication requests and then build the corresponding response. A given inbound authenticator has two parts. Request Processor Response Builder For each protocol supported by WSO2 Identity Server, there should be an inbound authenticator. This architecture component includes inbound authenticators for Security Assertion Markup Language (SAML) 2.0 , OpenID Connect , OAuth 2.0 , and WS-Federation (passive) . In other words, the responsibility of the SAML 2.0 request processor is to accept a SAML request from a service provider, validate the SAML request and then build a common object model understood by the authentication framework and handover the request to it. The responsibility of the SAML response builder is to accept a common object model from the authentication framework and build a SAML response out of it. Both the request processors and the response builders are protocol aware, while the authentication framework is not coupled to any protocol.","title":"Inbound authenticators"},{"location":"get-started/architecture/#local-authenticators","text":"The responsibility of the local authenticators is to authenticate the user with locally available credentials. This can be either user name /password or even IWA (Integrated Windows Authentication) . Local authenticators are decoupled from the Inbound Authenticators. Once the initial request is handed over to the authentication framework from an inbound authenticator, the authentication framework talks to the service provider configuration component to find the set of local authenticators registered with the service provider corresponding to the current authentication request. Once the local authentication is successfully completed, the local authenticator will notify the framework. The framework will now decide no more authentication is needed and hand over the control to the corresponding response builder of the inbound authenticator. You can develop your own local authenticators and plug them into the Identity Server.","title":"Local authenticators"},{"location":"get-started/architecture/#outboundfederated-authenticators","text":"The responsibility of the federated authenticators is to authenticate the user with an external system. This can be with Facebook, Google, Yahoo, LinkedIn, Twitter, Salesforce or any other identity provider. Federated authenticators are decoupled from the Inbound Authenticators. Once the initial request is handed over to the authentication framework from an inbound authenticator, the authentication framework talks to the service provider configuration component to find the set of federated authenticators registered with the service provider corresponding to the current authentication request. A federated authenticator has no value unless it is associated with an identity provider. The Identity Server out-of-the-box supports Security Assertion Markup Language (SAML) 2.0, OpenID Connect, OAuth 2.0, and WS-Federation (passive). The SAML 2 .0 federated authenticator itself has no value. It has to be associated with an Identity Provider. Google Apps can be an identity provider - with the SAML 2.0 federated authenticator. This federated authenticator knows how to generate a SAML request to the Google Apps and process a SAML response from it. There are two parts in a federated authenticator. Request Builder Response Processor Once the federation authentication is successfully completed, the federated authenticator will notify the authentication framework. The framework will now decide no more authentication is needed and hand over the control to the corresponding response builder of the inbound authenticator. Both the request builder and the response processor are protocol aware while the authentication framework is not coupled to any protocol. You can develop your own federated authenticators and plug them into the Identity Server.","title":"Outbound/federated authenticators"},{"location":"get-started/architecture/#multi-option-authenticators","text":"The service provider can define how to authenticate users at the Identity Server, for authentication requests initiated by it. While doing that, each service provider can pick more than one authenticator to allow end users to get multiple login options. This can be a combination of local authenticators and federated authenticators.","title":"Multi-option authenticators"},{"location":"get-started/architecture/#multi-factor-authenticators","text":"The service provider can define how to authenticate users at the Identity Server, for authentication requests initiated by it. While doing that, each service provider can define multiple steps and for each step it can pick more than one authenticator. The authentication framework tracks all the authenticators in each step and proceeds to the next step only if the user authenticates successfully in the current step. It is an AND between steps, while it is an OR between the authenticators in a given step.","title":"Multi-factor authenticators"},{"location":"get-started/architecture/#provisioning-framework","text":"The following are the provisioning components available in the provisioning framework.","title":"Provisioning framework"},{"location":"get-started/architecture/#inbound-provisioning","text":"Inbound provisioning focuses on how to provision users to the Identity Server. Out-of-the-box, the Identity Server supports inbound provisioning via a Simple Object Access Protocol ( SOAP) based API as well as the System for Cross-domain Identity Management ( SCIM) 1.1 API. Both the APIs support HTTP Basic Authentication. If you invoke the provisioning API with Basic Authentication credentials, then where to provision the user (to which user store) will be decided based on the inbound provisioning configuration of the resident service provider. The SCIM API also supports OAuth 2.0. If the user authenticates to the SCIM API with OAuth credentials, then the system will load the configuration corresponding to the service provider who owns the OAuth client id. If you plan to invoke the SCIM API via a web application or a mobile application, we would highly recommend you to use OAuth instead of Basic Authentication. You simply need to register your application as a service provider in Identity Server and then generate OAuth keys.","title":"Inbound provisioning"},{"location":"get-started/architecture/#just-in-time-provisioning","text":"Just-in-time (JIT) provisioning talks about how to provision users to the Identity Server at the time of federated authentication. A service provider initiates the authentication request, the user gets redirected to the Identity Server and then Identity Server redirects the user to an external identity provider for authentication. Just-in-time provisioning gets triggered in such a scenario when the Identity Server receives a positive authentication response from the external identity provider. The Identity Server will provision the user to its internal user store with the user claims from the authentication response. You configure JIT provisioning against an identity provider - not against service providers. Whenever you associate an identity provider with a service provider for outbound authentication, if the JIT provisioning is enabled for that particular identity provider, then the users from the external identity provider will be provisioned into the Identity Server's internal user store. In the JIT provisioning configuration you can also pick the provisioning user store. JIT provisioning happens while in the middle of an authentication flow. The provisioning can happen in a blocking mode or in a non-blocking mode. In the blocking mode, the authentication flow will be blocked till the provisioning finishes - while in the non-blocking mode, provisioning happens in a different thread.","title":"Just-in-time provisioning"},{"location":"get-started/architecture/#outbound-provisioning","text":"Outbound provisioning talks about provisioning users to external systems. This can be initiated by any of the following. Inbound provisioning request (initiated by a service provider or the resident service provider) JIT provisioning (initiated by a service provider) Adding a user via the management console (initiated by the resident service provider) Assigning a user to a provisioning role (initiated by the resident service provider) WSO2 Identity Server supports outbound provisioning with the following connectors. You need to configure one or more outbound provisioning connectors with a given identity provider, and associate the identity provider with a service provider. All the provisioning requests must be initiated by a service provider - and will be provisioned to all the identity providers configured in the outbound provisioning configuration of the corresponding service provider. SCIM SPML SOAP Google Apps provisioning API Salesforce provisioning API","title":"Outbound provisioning"},{"location":"get-started/architecture/#components-of-the-architecture","text":"The following table lists out the components pertaining to the architecture of the WSO2 Identity Server, which are depicted in the above figure and video. Component Description Process flow Service providers A Service Provider (SP) is an entity that provides Web services. A service provider relies on a trusted Identity Provider (IdP) for authentication and authorization. In this case, the Identity Server acts as the IdP and does the task of authenticating and authorizing the user of the service provider. Salesforce and Google Apps are examples of service providers and are used as such in this case. Related Links For information on how to add a service provider to the Identity Server, and do the necessary configurations to integrate the SP with the Identity Server, see Adding and Configuring a Service Provider . A user of the service provider (SP) attempts to log into the SPs application. The service provider sends an authentication request to the Identity Server. This request is met by the Inbound Authentication component of the Identity Server and comes in one of the following forms. SAML SSO OAuth/OpenID Connect Passive STS The service provider receives the authentication confirmation from the Identity Server once it follows all the specified processes required in order to authenticate the SP's user. Additionally, if a user registers in the service provider's application, a Simple Object Access Protocol ( SOAP) or System for Cross-domain Identity Management ( SCIM) request can be sent to the Identity Server. The request is met by the Inbound Provisioning component of the Identity Server. Inbound authentication The Inbound Authentication component of the Identity Server can handle any of the following requests. SAML SSO : Security Assertion Markup Language (SAML) is an OASIS open standard for representing and exchanging user identity and authentication data between parties. SAML provides the web-based Single-Sign-On capability. WSO2 IS supports SAML 2.0. OAuth/OpenID Connect : OAuth 2.0 has three main phases. They are; requesting an Authorization Grant, exchanging the Authorization Grant for an Access Token and accessing the resources using this Access Token. OpenID Connect is another identity layer on top of OAuth 2.0. OAuth applications can get authentication event information over the ID token and can get the extra claims of the authenticated user from the OpenID Connect UserInfo endpoint. WSO2 IS supports Oauth 1.0 and 2.0. Passive STS : A Security Token Service (STS) is a software based identity provider responsible for issuing security tokens, especially software tokens, as part of a claims-based identity system. Related Links For information on how to configure inbound authentication, see Configuring Inbound Authentication for a Service Provider . The inbound authentication component of the Identity Server receives the authentication request from the service provider. You can configure the Identity Server to receive either SAML SSO, OAuth/OpenID Connect, or WS-Federation requests. Your configuration depends on the service provider in question. Once the conditions are met in the inbound authentication component, the request is sent on to the authentication framework. Once the request is acted upon, a response from the OUT channel of the authentication framework is received by the inbound authentication component . This response is sent back to the service provider. Authentication framework Claim management is a key aspect of the Identity Server, which helps to map local claims to service provider claims and vice versa. It also enables you to map local claims to identity provider claims and vice versa. Just-in-Time (JIT) provisioning allows you to create users on the fly without having to create user accounts in advance. For example, if you recently added a user to your application, you don't need to manually create the user in the Identity Server. When they log in with single sign-on, their account is automatically created for them, eliminating the time and effort related to creating the account. Just-in-Time provisioning works with your identity provider to pass the correct user information to the Identity Server. Related Links For information on mapping local claims and service provider claims, see Configuring Claims for a Service Provider . For mapping local claims and identity provider claims, see Configuring Claims for an Identity Provider . For information on configuring Just-in-Time provisioning, see Configuring Just-In-Time Provisioning for an Identity Provider . The inbound authentication component sends the authentication request to the IN channel of the authentication framework. Here claim mapping is checked based on the configurations. Once this is done, the authentication request is sent onwards to either the local authenticators, the federated authenticators or both. Once the authentication is complete, a response is sent from the local and/or federated authenticators to the OUT channel of the authentication framework. The authentication framework handles mapping local claims to the IdP as required. Then the JIT provisioning component within the authentication framework sends this on to the provisioning framework. Once the request is acted upon, a response is sent from the OUT channel of the authentication framework back to the inbound authentication. Local authenticators Local authenticators are authentication processes available within the Identity Server itself. User name /password authentication happens by authenticating the credentials entered against the values in the user store connected to the Identity Server. Related Links For more information on how to configure local authenticators in the Identity Server, See Configuring Local and Outbound Authentication for a Service Provider . For more information about windows-based authentication, see Integrated Windows Authentication . The IN channel of the authentication framework sends the authentication request to the local authenticators component. The local authenticator does the authentication by checking the user name and password or by using Integrated Windows Authentication (IWA) . Once this is authentication is done, it provides the authentication response to the OUT channel of the authentication framework. Federated authenticators Federated authenticators are authentication processes that are not available within the Identity Server. These need to be configured to reach out to external applications to do the authentication process and send the response back to the Identity Server. Related Links For more information on how to configure federated authenticators with the various identity providers, see Configuring Federated Authentication . The IN channel of the authentication framework sends the authentication request to the federated authenticators component. The federated authenticators do the authentication by checking the authentication request in the specified authenticator. For example, if Facebook is configured, the authentication process will reflect that. Once this authentication is done, it provides the authentication response to the OUT channel of the authentication framework. Identity providers Identity providers perform authentication. To receive authentication requests from the Identity Server, configurations need to be done at the identity provider side as well . Identity providers are also known as external applications. The protocol specific authenticators (SAML2, OpenID Connect, WS-Federation (Passive)) represent applications that use these protocols for authentication requests. The authentication request comes in from the federated authenticators component and is sent to the relevant identity provider (External application). The user is authenticated and logged in to the relevant external application. A single authentication request can require authentication from multiple external applications. Provisioning framework The provisioning framework is responsible for all provisioning work done by the Identity Server. This framework integrates with the User Store Manager component and also receives provisioning requests from the authentication framework. The JIT provisioning component of the OUT channel in the authentication framework sends on the request to the provisioning framework. This occurs if the user is not added into the user store and needs to be added in on-the-fly. The provisioning framework sends the user details to the user store manager and the user is added. Once the user is added, the user store manager contacts the provisioning framework with the response. The SCIM and SOAP requests that arrive from the service provider are added to the user store manager. This information is also sent on the provisioning framework. The provisioning framework sends this along to the outbound provisioning component. Authorization manager WSO2 Identity Server contains an advanced entitlement auditing and management. It provides entitlement management for any REST or SOAP calls. WSO2 Identity Server provides attribute and claim-based access control via XACML, WS-Trust, OpenID Connect and claim management. WSO2 Identity Server also provides role-based access control (RBAC) and fine-grained policy-based access control via XACML. WSO2 Identity Server provides a friendly user interface for policy editing. It also supports multiple Policy Information Point (PIP) and policy distribution to various Policy Decision Points (PDPs). It provides a high-performance network protocol (over Thrift) for PEP/PDP interaction, and policy decision and attribute caching. Notifications are provided for policy updates. Moreover, the WSO2 Carbon TryIt tool that comes bundled with the Identity Server lets the user explore the policy impact. Related Links For more information on how to use and manage entitlement within the Identity Server, see Working with Entitlement . Authorization does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. This is primarily a functionality that can be managed using APIs that are written to perform authorization tasks. IdP and SP configurations The identity provider and service provider configurations provide the basis for all actions that happen within the authentication framework and provisioning framework. Related Links For more information on how to configure the service provider, see Adding and Configuring a Service Provider . For more information on how to configure the identity provider, see Adding and Configuring an Identity Provider . The identity provider and service provider configurations go to both the authentication framework and provisioning framework. Inbound provisioning Inbound provisioning requests can come in the form of SCIM or SOAP. The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in the WSO2 Identity Server easier. Identity provisioning is a key aspect of any Identity Management Solution. In simple terms, it is to create, maintain and delete user accounts and related identities in one or more systems or applications in response to business processes which are initiated either by humans directly or by automated tasks. Simple Object Access Protocol (SOAP) is a protocol for exchanging XML-based messages over a network, normally using HTTP. SOAP forms the foundation layer of the Web services stack, providing a basic messaging framework that more abstract layers can build on. SOAP services are defined using Web Services Definition Language (WSDL) and are accessible using a URL that is known as a SOAP endpoint. Here, a SOAP API is used to provision users to the Identity Server. Related Links For more information on configuring inbound provisioning, see Configuring Inbound Provisioning for a Service Provider . The SCIM or SOAP request comes into the inbound provisioning component from the service provider. The inbound provisioning component receives this request, processes it based on the configurations and sends the request on to the user store manager. User store manager WSO2 Identity Server implements flexible user store via built-in LDAP (powered by ApacheDS), external LDAP, Microsoft Active Directory or any JDBC database. It provides an API for integrating identity management to any application. WSO2 Identity Server allows tenants/organizations to configure their user stores through the admin console. WSO2 Identity Server supports multiple profiles per user using its flexible profile management feature. Related Links For more information, see User Management Architecture For more information on how to configure user stores, see Configuring the Realm . For more information on how to work with users and roles, see Configuring Users, Roles and Permissions . The user store manager receives provisioning requests from the provisioning framework. These provisioning requests are handled and the relevant user store is updated. The request can affect multiple user stores if the configuration is such. Once this request has been handled, an update is sent back to the provisioning framework. The inbound provisioning component sends SCIM and SOAP provisioning requests on to the user store manager. The user store manager receives the provisioning request, acts on it and sends it on to the provisioning framework where it has to be sent on for outbound provisioning. Claim manager A claim is a piece of information about a particular subject. It can be anything that the subject is owned by or associated with, such as name, group, preferences, etc. A claim provides a single and general notion to define the identity information related to the subject. Claim-based identity is a common way for any application to acquire the identity information. It provides a consistent approach for all applications by hiding the lower level implementation. Claims are also used in identity propagation, by packaging the claims into one or more tokens (such as SAML). These tokens are then issued by an issuer; commonly known as a security token service (STS). Related Links For more information on managing claims, see Claim Management For information on how to configure claims on the service provider side, see Configuring Claims for a Service Provider For information on how to configure claims on the identity provider side, See Configuring Claims for an Identity Provider . Claim management does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. Primarily, it integrates with the following four components. Authentication framework Authorization manager Provisioning framework User store manager XACML eXtensible Access Control Markup Language ( XACML) is ideally a part of the authorization manager component but it is depicted separately due to its unique role in the Identity Server architecture. XACML is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that enable it to surpass being just a fine grain authorization mechanism. XACML describes access control policy language, request/response language and reference architecture. The policy language is used to express access control policies (who can do what when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). eXtensible Access Control Markup Language ( XACML) does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. Auditing WSO2 Identity Server supports auditing of privileged operations using distributed auditing system (XDAS). It also allows you to monitor and collect standard access and performance statistics. The Analytics component of WSO2 Identity Server supports monitoring session and authentication statistics. Auditing does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server. IS can be configured to produce audit logs for all of its components but the following components are most commonly used for logging details. Authentication framework Provisioning framework User store manager Identity manager Enterprise IT Systems are constantly changing; their perimeters are expanding and their policies keep changing. Therefore, in such a rapidly evolving world, security solutions need to be forward thinking and innovative. They need to be configurable in order to keep pace and adapt to rapid changes. This can be achieved by the identity manager component because it caters to security requirements at hand as well as looking toward the future. It has a very customizable user interface and can be easily implemented in order to ensure maximum security for your system. Identity manager does not play a direct role in the process flow but as a component, it integrates with various other components in the Identity Server, primarily the user store manager. Outbound provisioning The Outbound Provisioning component of the Identity Server can send provisioning requests to applications that support the following connectors. SCIM SPML Google Salesforce These connectors reach out to identity providers that perform the provisioning. Related Links For more information on how to configure outbound provisioning connectors, see Configuring Outbound Provisioning Connectors for an Identity Provider . The provisioning request comes into the outbound provisioning component from the provisioning framework. This request will go to the relevant connector. Related Links For further reading about the architecture in an Identity and Access Management solution, see the following article: Identity Architect Ground Rules: Ten IAM Design Principles .","title":"Components of the architecture"},{"location":"get-started/cross-protocol-single-logout/","text":"Cross Protocol Single Logout \u00b6 WSO2 Identity Server supports Single Sign-On (SSO) for multiple applications that are using different authentication protocols. Just like Single Sign-On, Single Logout (SLO) allows you to logout all apps in the current browser session when one application performs a logout. Although SSO is commonly supported across different protocols, e.g., SAML and OIDC, SLO used to be supported only within the protocol of the application that initiates the logout. WSO2 Identity Server now supports SLO across different protocols. For example, suppose you have logged in to two applications that use two different authentication protocols (OIDC and SAML) from the same browser using SSO. With cross-protocol logout, when you log out from one of these two applications, you will be automatically logged out from the other application despite the protocol difference. As of now, WSO2 Identity Server supports cross-protocol logout over SAML and OIDC protocols. Note In relation to SAML applications, cross-protocol logout is only supported for SAML applications that use backchannel logout.","title":"Cross Protocol Single Logout"},{"location":"get-started/cross-protocol-single-logout/#cross-protocol-single-logout","text":"WSO2 Identity Server supports Single Sign-On (SSO) for multiple applications that are using different authentication protocols. Just like Single Sign-On, Single Logout (SLO) allows you to logout all apps in the current browser session when one application performs a logout. Although SSO is commonly supported across different protocols, e.g., SAML and OIDC, SLO used to be supported only within the protocol of the application that initiates the logout. WSO2 Identity Server now supports SLO across different protocols. For example, suppose you have logged in to two applications that use two different authentication protocols (OIDC and SAML) from the same browser using SSO. With cross-protocol logout, when you log out from one of these two applications, you will be automatically logged out from the other application despite the protocol difference. As of now, WSO2 Identity Server supports cross-protocol logout over SAML and OIDC protocols. Note In relation to SAML applications, cross-protocol logout is only supported for SAML applications that use backchannel logout.","title":"Cross Protocol Single Logout"},{"location":"get-started/identity-anti-patterns-and-the-identity-bus/","text":"Identity Anti-patterns and the Identity Bus \u00b6 This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus. Spaghetti identity and federation silos \u00b6 According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems. How this impacts enterprise identity management \u00b6 When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this. The identity bus \u00b6 Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \"http://sp1.org/claims/email\" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai\". Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider.","title":"Identity Anti-patterns and the Identity Bus"},{"location":"get-started/identity-anti-patterns-and-the-identity-bus/#identity-anti-patterns-and-the-identity-bus","text":"This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus.","title":"Identity Anti-patterns and the Identity Bus"},{"location":"get-started/identity-anti-patterns-and-the-identity-bus/#spaghetti-identity-and-federation-silos","text":"According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems.","title":"Spaghetti identity and federation silos"},{"location":"get-started/identity-anti-patterns-and-the-identity-bus/#how-this-impacts-enterprise-identity-management","text":"When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this.","title":"How this impacts enterprise identity management"},{"location":"get-started/identity-anti-patterns-and-the-identity-bus/#the-identity-bus","text":"Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \"http://sp1.org/claims/email\" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai\". Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider.","title":"The identity bus"},{"location":"get-started/identity-provisioning-and-its-standards/","text":"Identity Provisioning and its Standards \u00b6 User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram. Inbound and outbound provisioning \u00b6 Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications. Introducing SPML \u00b6 Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions Introducing SCIM \u00b6 The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability. Brief history of identity provisioning \u00b6 Click here to read about the history of identity provisioning The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language(ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM)) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far.","title":"Identity Provisioning and its Standards"},{"location":"get-started/identity-provisioning-and-its-standards/#identity-provisioning-and-its-standards","text":"User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram.","title":"Identity Provisioning and its Standards"},{"location":"get-started/identity-provisioning-and-its-standards/#inbound-and-outbound-provisioning","text":"Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications.","title":"Inbound and outbound provisioning"},{"location":"get-started/identity-provisioning-and-its-standards/#introducing-spml","text":"Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions","title":"Introducing SPML"},{"location":"get-started/identity-provisioning-and-its-standards/#introducing-scim","text":"The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability.","title":"Introducing SCIM"},{"location":"get-started/identity-provisioning-and-its-standards/#brief-history-of-identity-provisioning","text":"Click here to read about the history of identity provisioning The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language(ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM)) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far.","title":"Brief history of identity provisioning"},{"location":"get-started/introduction/","text":"Introduction \u00b6 The topics in this section introduce WSO2 Identity Server, including the business cases it solves, its features, and architecture. Overview Architecture About this release You can also view the following webinars and articles to expand your knowledge on WSO2 Identity Server: Connected Identity - Benefits, Risks and Challenges Identity and Entitlement Management - Concepts and Theories","title":"Introduction"},{"location":"get-started/introduction/#introduction","text":"The topics in this section introduce WSO2 Identity Server, including the business cases it solves, its features, and architecture. Overview Architecture About this release You can also view the following webinars and articles to expand your knowledge on WSO2 Identity Server: Connected Identity - Benefits, Risks and Challenges Identity and Entitlement Management - Concepts and Theories","title":"Introduction"},{"location":"get-started/overview/","text":"Overview \u00b6 As an enterprise's applications, services, and API adoptions grow, managing identities (such as employees, vendors, partners, and customers) across internal, shared, and SaaS services becomes a significant challenge. The WSO2 Identity Server is a product that can meet this challenge and also provide options to solve identity problems you may encounter in future. WSO2 Identity Server is fully open source and is released under Apache Software License Version 2.0, one of the most business-friendly licenses available today. About identity in the connected world \u00b6 In the connected world of today, the modern enterprises have to offer their numerous customers remote access to sizable amounts of sensitive and confidential information, while still maintaining access control and stringent information security at all times. Additionally, all of this needs to take place at the bat of an eyelid. A typical connected business of today relies on users who are constantly on the move and using various applications and devices. These users are now using their own devices for ease of access and prefer to sign in just once. Basically, the connected business caters to people who would like to use their Facebook, Google, or LinkedIn credentials to access other information on their own devices. Here\u2019s the catch: an individual\u2019s identity needs to be validated across these applications, and this needs to take place in a manner that will ensure security as well as speed of access and ease of use. Identity management \u00b6 Identity management is used to directly influence the security and productivity of an organization. This can enforce consistency in security policies across the organization. Identity management is particularly advantageous when complying with rules and regulations enforced in some critical domains by governments. This can also be a means to provide access to resources to outside parties without compromising security. Controlling access to resources increases organizational security. A system that uses a proper identity management solution is easier to audit. Additionally, there are automated password reset capabilities. An identity management system would typically have the following. User stores and directories Authentication of users Authorization of users Single sign-on Provisioning Access delegation Password reset Self-registration Account locking The Identity Server and the solution it provides \u00b6 WSO2 Identity Server provides secure identity management for enterprise web applications, services, and APIs by managing identity and entitlements of the users securely and efficiently. The Identity Server enables enterprise architects and developers to reduce identity provisioning time, guarantee secure online interactions, and deliver a reduced single sign-on environment. The WSO2 Identity Server decreases the identity management and entitlement management administration burden by including the role-based access control (RBAC) convention, fine-grained policy-based access control, and Single-Sign-On (SSO) bridging. The Identity Server enables you to create, maintain and terminate user accounts along with user identities across multiple systems including Cloud applications. When there are multiple applications that require authentication, users should be able to log in at one place and still have seamless access to all the other applications. Additionally, the Identity Server brings about a new and improved approach to federation. There is a centralized Identity as a Service Provider. It is still an overall n to n relationship. There is a 1 to n relationship from a federation partner to consumer services (where multiple consumer services rely on a single centralized federated Identity Provider for security) and a 1 to n relationship from consumer service to federation partners (where a single consumer service can rely on multiple Identity providers for security). This model ensures greater efficiency. WSO2 Identity Server has the \u2018 Jaggery \u2019 user interface for end users. Apart from the Management Console , an end user view is available to manage profiles, to recover accounts and to manage authorized apps. The log in and consent pages in the UI can be completely customized because they run on a separate context as a separate web application. These web applications can even be dropped into a separate application server if required.","title":"Introduction"},{"location":"get-started/overview/#overview","text":"As an enterprise's applications, services, and API adoptions grow, managing identities (such as employees, vendors, partners, and customers) across internal, shared, and SaaS services becomes a significant challenge. The WSO2 Identity Server is a product that can meet this challenge and also provide options to solve identity problems you may encounter in future. WSO2 Identity Server is fully open source and is released under Apache Software License Version 2.0, one of the most business-friendly licenses available today.","title":"Overview"},{"location":"get-started/overview/#about-identity-in-the-connected-world","text":"In the connected world of today, the modern enterprises have to offer their numerous customers remote access to sizable amounts of sensitive and confidential information, while still maintaining access control and stringent information security at all times. Additionally, all of this needs to take place at the bat of an eyelid. A typical connected business of today relies on users who are constantly on the move and using various applications and devices. These users are now using their own devices for ease of access and prefer to sign in just once. Basically, the connected business caters to people who would like to use their Facebook, Google, or LinkedIn credentials to access other information on their own devices. Here\u2019s the catch: an individual\u2019s identity needs to be validated across these applications, and this needs to take place in a manner that will ensure security as well as speed of access and ease of use.","title":"About identity in the connected world"},{"location":"get-started/overview/#identity-management","text":"Identity management is used to directly influence the security and productivity of an organization. This can enforce consistency in security policies across the organization. Identity management is particularly advantageous when complying with rules and regulations enforced in some critical domains by governments. This can also be a means to provide access to resources to outside parties without compromising security. Controlling access to resources increases organizational security. A system that uses a proper identity management solution is easier to audit. Additionally, there are automated password reset capabilities. An identity management system would typically have the following. User stores and directories Authentication of users Authorization of users Single sign-on Provisioning Access delegation Password reset Self-registration Account locking","title":"Identity management"},{"location":"get-started/overview/#the-identity-server-and-the-solution-it-provides","text":"WSO2 Identity Server provides secure identity management for enterprise web applications, services, and APIs by managing identity and entitlements of the users securely and efficiently. The Identity Server enables enterprise architects and developers to reduce identity provisioning time, guarantee secure online interactions, and deliver a reduced single sign-on environment. The WSO2 Identity Server decreases the identity management and entitlement management administration burden by including the role-based access control (RBAC) convention, fine-grained policy-based access control, and Single-Sign-On (SSO) bridging. The Identity Server enables you to create, maintain and terminate user accounts along with user identities across multiple systems including Cloud applications. When there are multiple applications that require authentication, users should be able to log in at one place and still have seamless access to all the other applications. Additionally, the Identity Server brings about a new and improved approach to federation. There is a centralized Identity as a Service Provider. It is still an overall n to n relationship. There is a 1 to n relationship from a federation partner to consumer services (where multiple consumer services rely on a single centralized federated Identity Provider for security) and a 1 to n relationship from consumer service to federation partners (where a single consumer service can rely on multiple Identity providers for security). This model ensures greater efficiency. WSO2 Identity Server has the \u2018 Jaggery \u2019 user interface for end users. Apart from the Management Console , an end user view is available to manage profiles, to recover accounts and to manage authorized apps. The log in and consent pages in the UI can be completely customized because they run on a separate context as a separate web application. These web applications can even be dropped into a separate application server if required.","title":"The Identity Server and the solution it provides"},{"location":"get-started/provisioning-architecture/","text":"Provisioning Architecture \u00b6 The provisioning framework is responsible for all provisioning work done by the WSO2 Identity Server. This framework integrates with the User Store Manager component and also receives provisioning requests from the authentication framework. Inbound provisioning \u00b6 Inbound provisioning focuses on how to provision users to the Identity Server. Out-of-the-box, the Identity Server supports inbound provisioning via a SOAP-based API as well as the SCIM 1.1 API. Both the APIs support HTTP Basic Authentication. If you invoke the provisioning API with Basic Authentication credentials, then where to provision the user (to which user store) will be decided based on the inbound provisioning configuration of the resident service provider. The SCIM API also supports OAuth 2.0. If the user authenticates to the SCIM API with OAuth credentials, then the system will load the configuration corresponding to the service provider who owns the OAuth client id. If you plan to invoke the SCIM API via a web application or a mobile application, we would highly recommend you to use OAuth instead of Basic Authentication. You simply need to register your application as a service provider in Identity Server and then generate OAuth keys. JIT provisioning \u00b6 Just-in-time provisioning talks about how to provision users to the Identity Server at the time of federated authentication. A service provider initiates the authentication request, the user gets redirected to the Identity Server and then Identity Server redirects the user to an external identity provider for authentication. Just-in-time provisioning gets triggered in such a scenario when the Identity Server receives a positive authentication response from the external identity provider. The Identity Server will provision the user to its internal user store with the user claims from the authentication response. You configure JIT provisioning against an identity provider - not against service providers. Whenever you associate an identity provider with a service provider for outbound authentication, if the JIT provisioning is enabled for that particular identity provider, then the users from the external identity provider will be provisioned into the Identity Server's internal user store. In the JIT provisioning configuration you can also pick the provisioning user store. Outbound provisioning \u00b6 Outbound provisioning talks about provisioning users to external systems. This can be initiated by any of the following. Inbound provisioning request (initiated by a service provider or the resident service provider) JIT provisioning (initiated by a service provider) Adding a user via the management console (initiated by the the resident service provider) Assigning a user to a provisioning role (initiated by the the resident service provider) WSO2 Identity Server supports outbound provisioning with the following connectors. You need to configure one or more outbound provisioning connectors with a given identity provider, and associate the identity provider with a service provider. All the provisioning requests must be initiated by a service provider - and will be provisioned to all the identity providers configured in the outbound provisioning configuration of the corresponding service provider. SCIM SPML SOAP Google Apps provisioning API Salesforce provisioning API JIT provisioning happens while in the middle of an authentication flow. The provisioning can happen in a blocking mode or in a non-blocking mode. In the blocking mode, the authentication flow will be blocked till the provisioning finishes - while in the non-blocking mode, provisioning happens in a different thread. Conditional provisioning with roles \u00b6 If you want to provision a user to an external identity provider, for example to Salesforce or Google Apps, based on the user's role, then you need to define one or more provisioning roles in the outbound provisioning configuration of the corresponding identity provider. SCIM implementation using WSO2 Charon \u00b6 WSO2 Charon is an open source implementation of SCIM protocol, which is an open standard for Identity Provisioning. It can be used by any one who wants to add SCIM-based provisioning support for their applications. WSO2 Charon is integrated with WSO2 Identity Server. This page demonstrates the utilization of SCIM endpoints which expose User and Group resources in a RESTful way. The following is a high level overview of SCIM Service Provider architecture of IS. WSO2 Charon is one of the SCIM implementations that are made available under Apache 2.0 license. Charon includes libraries used by SCIM in the WSO2 Identity Server. The following diagram provides an overview on the module breakdown of Charon along with purpose of each module and planned tasks of them. The following includes a brief introduction on each of the modules. Charon-Core : This is the API that exposes an implementation of the SCIM specification. It can be used by any SCIM service provider or client implementation to support SCIM operations/functionalities. In addition to that, it also allows room for extension points to be plugged in according to the particular server side/client side implementation, such as authentication handler, user storage, encoders/decoders etc. Charon-Utils : This contains a set of default implementations of the extension points mentioned above. For example: Basic Auth, OAuth handlers, LDAP based user storage etc. A particular implementation that uses charon-core as SCIM API can use these default implementations as building blocks. Charon-Deployment (Note: this is renamed as Charon-Impl): A reference implementation of SCIM service provider is shipped with this module. Currently it is a Apache Wink based web app that can be deployed in any application server - such as Tomcat, and enables the SCIM endpoints to be exposed. This is based on the above two modules: charon-core and charon-utils, and illustrates how any SCIM implementation can utilize the API and supporting module provided by Charon. Charon-Samples : This contains samples illustrating the SCIM use cases. Samples mainly contain the SCIM client side implementations which can be run against a SCIM server, and hence can also be referenced to get to know how the API provided by Charon can be used to implement SCIM client side. Charon-Deployment \u00b6 Charon-Deployment is the reference implementation of SCIM service provider that is shipped with Charon. The following illustrates how any concrete implementation of a SCIM service provider can make use of Charon-Core (the SCIM API) with Charon-Utils (optional). The SCIM service provider needs to be a RESTful web application. REST is an architectural style of building networked applications. There are several ways to implement REST style based applications - such as Servlets and JAX-RS based frameworks. In the reference implementation of Charon-SCIM service provider, the latter approach is selected since JAX-RS hides underlying HTTP handling and binds the servlets nicely to individual methods in the Java classes using annotations. Annotations can also dynamically extract information from HTTP requests and map application-generated exceptions to HTTP response codes. Out of the JAX-RS implementations, Apache-Wink was selected since it better catered to the requirements. The Charon-Impl module creates an Apache-Wink based web application which can be deployed in an application server like Tomcat and which acts as a SCIM service provider. The following is a deployment diagram of Charon-SCIM service provider (the web application provided by Charon-Impl module). It also gives a high level idea on how Charon-Core and Charon-Utils modules are utilized. As this diagram of the reference implementation illustrates, a SCIM service provider can be developed using any REST implementation and SCIM-defined resources can be exposed utilizing the API provided by the Charon-Core. On the other hand, SCIM Consumers can also be implemented using the client API of Charon-Core. Extensible SCIM user schemas \u00b6 The SCIM (System for Cross-Domain Identity Management) specification defines a fixed set of default attributes for the user object. This set is defined to ensure the interoperability and it can cater to most of the industry's identity management requirements. Given below is a sample user object with the default attributes set. However the SCIM specification itself introduces the Enterprise User Extension to support extra attributes for the SCIM user object. However the reality in the industry is that organizations have their own attributes defined for the users. These attributes are already there in their LDAP schemas. Therefore SCIM should be extensible enough to cope with these custom attributes of the users. WSO2 Identity Server allows users to define their own user schema in a configuration file ( [IS-HOME]/repository/conf/scim-schema-extension.config ). Then these configured schema are used while creating, validating user objects. With this the users can pass their custom attributes of users over SCIM for Identity Management requirements. The implementation is adhering to the Schema Extension Model . Given below is a sample extended user object with the default schema configuration. Enable Extension \u00b6 Locate the provisioning-config.xml file in the path [IS-HOME]/repository/conf/identity/provisioning-config.xml . Open the file and locate the user-schema-extension-enabled property. Ensure that the property value is set to true . Save the file and restart the server. Claims Mapping \u00b6 Log into the Identity Server and do the claim mapping for the following claim URIs (see here for more information on how to do claim mappings). urn:scim:schemas:extension:wso2:1.0:wso2Extension.costCenter urn:scim:schemas:extension:wso2:1.0:wso2Extension.department urn:scim:schemas:extension:wso2:1.0:wso2Extension.division urn:scim:schemas:extension:wso2:1.0:wso2Extension.employeeNumber urn:scim:schemas:extension:wso2:1.0:wso2Extension.organization urn:scim:schemas:extension:wso2:1.0:wso2Extension.manager.displayName urn:scim:schemas:extension:wso2:1.0:wso2Extension.manager.managerId Now the server is up and running with the new extended user schema. The claim mappings can map the SCIM user attributes to the LDAP user attributes. Create a new user with the new schema. The following screen depicts the user to be added with the wso2Extension attributes. cURL commands \u00b6 Given below are the cURL commands to add a user. The attribute name for the wso2Extension is EnterpriseUser . Primary Userstore Command curl -v -k --user admin:admin --data \"{\"schemas\":[],\"userName\":\"SureshAtt\",\"password\":\"Wso2@123\",\"EnterpriseUser\":{\"employeeNumber\":\"000111\",\"costCenter\":\"111111\",\"organization\":\"WSO2Org\",\"division\":\"Engineering\",\"department\":\"Intigration\",\"manager\":{\"managerId\":\"111000\",\"displayName\":\"Prabath\"}}}\" --header \"Content-Type:application/json\" https://localhost:9443/wso2/scim/Users Secondary Userstore Command curl -v -k --user admin:admin --data \"{\"schemas\":[],\"userName\":'mysql/uresh67',\"password\":\"Wso2@123\"}\" --header \"Content-Type:application/json\" https://localhost:9443/wso2/scim/Users Note that the user name is preceded by the domain and is within single quotes 'mysql/uresh67'. Also note that 'mysql' here is a reference to a domain name. The above command provides the following results: Primary Userstore Output {\"id\":\"db4f9c15-8426-4381-a669-270975d50421\",\"EnterpriseUser\":{\"organization\":\"WSO2Org\",\"manager\":{\"managerId\":\"111000\",\"displayName\":\"Prabath\"},\"division\":\"Engineering\",\"department\":\"Intigration\",\"costCenter\":\"111111\",\"employeeNumber\":\"73\"},\"schemas\":[\"urn:scim:schemas:core:1.0\",\"urn:scim:schemas:extension:wso2:1.0\"],\"userName\":\"SureshAtt\",\"meta\":{\"lastModified\":\"2013-07-09T13:27:58\",\"location\":\"https://localhost:9443/wso2/scim/Users/db4f9c15-8426-4381-a669-270975d50421\",\"created\":\"2013-07-09T13:27:58\"}} Secondary Userstore Output {\"id\":\"2e89cac0-17f3-40e7-8a07-ff1047a70cf1\",\"schemas\":[\"urn:scim:schemas:core:1.0\"],\"userName\":\"mysql/uresh67\",\"meta\":{\"lastModified\":\"2013-12-17T14:31:30\",\"location\":\"https://localhost:9443/wso2/scim/Users/2e89cac0-17f3-40e7-8a07-ff1047a70cf1\",\"created\":\"2013-12-17T14:31:30\"}}* Closing connection #0 The created SCIM user object can be viewed in the following screen: Related links \u00b6 See SCIM 1.1 APIs for more cURL commands that can be used to do various functions using the SCIM endpoints available.","title":"Provisioning Architecture"},{"location":"get-started/provisioning-architecture/#provisioning-architecture","text":"The provisioning framework is responsible for all provisioning work done by the WSO2 Identity Server. This framework integrates with the User Store Manager component and also receives provisioning requests from the authentication framework.","title":"Provisioning Architecture"},{"location":"get-started/provisioning-architecture/#inbound-provisioning","text":"Inbound provisioning focuses on how to provision users to the Identity Server. Out-of-the-box, the Identity Server supports inbound provisioning via a SOAP-based API as well as the SCIM 1.1 API. Both the APIs support HTTP Basic Authentication. If you invoke the provisioning API with Basic Authentication credentials, then where to provision the user (to which user store) will be decided based on the inbound provisioning configuration of the resident service provider. The SCIM API also supports OAuth 2.0. If the user authenticates to the SCIM API with OAuth credentials, then the system will load the configuration corresponding to the service provider who owns the OAuth client id. If you plan to invoke the SCIM API via a web application or a mobile application, we would highly recommend you to use OAuth instead of Basic Authentication. You simply need to register your application as a service provider in Identity Server and then generate OAuth keys.","title":"Inbound provisioning"},{"location":"get-started/provisioning-architecture/#jit-provisioning","text":"Just-in-time provisioning talks about how to provision users to the Identity Server at the time of federated authentication. A service provider initiates the authentication request, the user gets redirected to the Identity Server and then Identity Server redirects the user to an external identity provider for authentication. Just-in-time provisioning gets triggered in such a scenario when the Identity Server receives a positive authentication response from the external identity provider. The Identity Server will provision the user to its internal user store with the user claims from the authentication response. You configure JIT provisioning against an identity provider - not against service providers. Whenever you associate an identity provider with a service provider for outbound authentication, if the JIT provisioning is enabled for that particular identity provider, then the users from the external identity provider will be provisioned into the Identity Server's internal user store. In the JIT provisioning configuration you can also pick the provisioning user store.","title":"JIT provisioning"},{"location":"get-started/provisioning-architecture/#outbound-provisioning","text":"Outbound provisioning talks about provisioning users to external systems. This can be initiated by any of the following. Inbound provisioning request (initiated by a service provider or the resident service provider) JIT provisioning (initiated by a service provider) Adding a user via the management console (initiated by the the resident service provider) Assigning a user to a provisioning role (initiated by the the resident service provider) WSO2 Identity Server supports outbound provisioning with the following connectors. You need to configure one or more outbound provisioning connectors with a given identity provider, and associate the identity provider with a service provider. All the provisioning requests must be initiated by a service provider - and will be provisioned to all the identity providers configured in the outbound provisioning configuration of the corresponding service provider. SCIM SPML SOAP Google Apps provisioning API Salesforce provisioning API JIT provisioning happens while in the middle of an authentication flow. The provisioning can happen in a blocking mode or in a non-blocking mode. In the blocking mode, the authentication flow will be blocked till the provisioning finishes - while in the non-blocking mode, provisioning happens in a different thread.","title":"Outbound provisioning"},{"location":"get-started/provisioning-architecture/#conditional-provisioning-with-roles","text":"If you want to provision a user to an external identity provider, for example to Salesforce or Google Apps, based on the user's role, then you need to define one or more provisioning roles in the outbound provisioning configuration of the corresponding identity provider.","title":"Conditional provisioning with roles"},{"location":"get-started/provisioning-architecture/#scim-implementation-using-wso2-charon","text":"WSO2 Charon is an open source implementation of SCIM protocol, which is an open standard for Identity Provisioning. It can be used by any one who wants to add SCIM-based provisioning support for their applications. WSO2 Charon is integrated with WSO2 Identity Server. This page demonstrates the utilization of SCIM endpoints which expose User and Group resources in a RESTful way. The following is a high level overview of SCIM Service Provider architecture of IS. WSO2 Charon is one of the SCIM implementations that are made available under Apache 2.0 license. Charon includes libraries used by SCIM in the WSO2 Identity Server. The following diagram provides an overview on the module breakdown of Charon along with purpose of each module and planned tasks of them. The following includes a brief introduction on each of the modules. Charon-Core : This is the API that exposes an implementation of the SCIM specification. It can be used by any SCIM service provider or client implementation to support SCIM operations/functionalities. In addition to that, it also allows room for extension points to be plugged in according to the particular server side/client side implementation, such as authentication handler, user storage, encoders/decoders etc. Charon-Utils : This contains a set of default implementations of the extension points mentioned above. For example: Basic Auth, OAuth handlers, LDAP based user storage etc. A particular implementation that uses charon-core as SCIM API can use these default implementations as building blocks. Charon-Deployment (Note: this is renamed as Charon-Impl): A reference implementation of SCIM service provider is shipped with this module. Currently it is a Apache Wink based web app that can be deployed in any application server - such as Tomcat, and enables the SCIM endpoints to be exposed. This is based on the above two modules: charon-core and charon-utils, and illustrates how any SCIM implementation can utilize the API and supporting module provided by Charon. Charon-Samples : This contains samples illustrating the SCIM use cases. Samples mainly contain the SCIM client side implementations which can be run against a SCIM server, and hence can also be referenced to get to know how the API provided by Charon can be used to implement SCIM client side.","title":"SCIM implementation using WSO2 Charon"},{"location":"get-started/provisioning-architecture/#charon-deployment","text":"Charon-Deployment is the reference implementation of SCIM service provider that is shipped with Charon. The following illustrates how any concrete implementation of a SCIM service provider can make use of Charon-Core (the SCIM API) with Charon-Utils (optional). The SCIM service provider needs to be a RESTful web application. REST is an architectural style of building networked applications. There are several ways to implement REST style based applications - such as Servlets and JAX-RS based frameworks. In the reference implementation of Charon-SCIM service provider, the latter approach is selected since JAX-RS hides underlying HTTP handling and binds the servlets nicely to individual methods in the Java classes using annotations. Annotations can also dynamically extract information from HTTP requests and map application-generated exceptions to HTTP response codes. Out of the JAX-RS implementations, Apache-Wink was selected since it better catered to the requirements. The Charon-Impl module creates an Apache-Wink based web application which can be deployed in an application server like Tomcat and which acts as a SCIM service provider. The following is a deployment diagram of Charon-SCIM service provider (the web application provided by Charon-Impl module). It also gives a high level idea on how Charon-Core and Charon-Utils modules are utilized. As this diagram of the reference implementation illustrates, a SCIM service provider can be developed using any REST implementation and SCIM-defined resources can be exposed utilizing the API provided by the Charon-Core. On the other hand, SCIM Consumers can also be implemented using the client API of Charon-Core.","title":"Charon-Deployment"},{"location":"get-started/provisioning-architecture/#extensible-scim-user-schemas","text":"The SCIM (System for Cross-Domain Identity Management) specification defines a fixed set of default attributes for the user object. This set is defined to ensure the interoperability and it can cater to most of the industry's identity management requirements. Given below is a sample user object with the default attributes set. However the SCIM specification itself introduces the Enterprise User Extension to support extra attributes for the SCIM user object. However the reality in the industry is that organizations have their own attributes defined for the users. These attributes are already there in their LDAP schemas. Therefore SCIM should be extensible enough to cope with these custom attributes of the users. WSO2 Identity Server allows users to define their own user schema in a configuration file ( [IS-HOME]/repository/conf/scim-schema-extension.config ). Then these configured schema are used while creating, validating user objects. With this the users can pass their custom attributes of users over SCIM for Identity Management requirements. The implementation is adhering to the Schema Extension Model . Given below is a sample extended user object with the default schema configuration.","title":"Extensible SCIM user schemas"},{"location":"get-started/provisioning-architecture/#enable-extension","text":"Locate the provisioning-config.xml file in the path [IS-HOME]/repository/conf/identity/provisioning-config.xml . Open the file and locate the user-schema-extension-enabled property. Ensure that the property value is set to true . Save the file and restart the server.","title":"Enable Extension"},{"location":"get-started/provisioning-architecture/#claims-mapping","text":"Log into the Identity Server and do the claim mapping for the following claim URIs (see here for more information on how to do claim mappings). urn:scim:schemas:extension:wso2:1.0:wso2Extension.costCenter urn:scim:schemas:extension:wso2:1.0:wso2Extension.department urn:scim:schemas:extension:wso2:1.0:wso2Extension.division urn:scim:schemas:extension:wso2:1.0:wso2Extension.employeeNumber urn:scim:schemas:extension:wso2:1.0:wso2Extension.organization urn:scim:schemas:extension:wso2:1.0:wso2Extension.manager.displayName urn:scim:schemas:extension:wso2:1.0:wso2Extension.manager.managerId Now the server is up and running with the new extended user schema. The claim mappings can map the SCIM user attributes to the LDAP user attributes. Create a new user with the new schema. The following screen depicts the user to be added with the wso2Extension attributes.","title":"Claims Mapping"},{"location":"get-started/provisioning-architecture/#curl-commands","text":"Given below are the cURL commands to add a user. The attribute name for the wso2Extension is EnterpriseUser . Primary Userstore Command curl -v -k --user admin:admin --data \"{\"schemas\":[],\"userName\":\"SureshAtt\",\"password\":\"Wso2@123\",\"EnterpriseUser\":{\"employeeNumber\":\"000111\",\"costCenter\":\"111111\",\"organization\":\"WSO2Org\",\"division\":\"Engineering\",\"department\":\"Intigration\",\"manager\":{\"managerId\":\"111000\",\"displayName\":\"Prabath\"}}}\" --header \"Content-Type:application/json\" https://localhost:9443/wso2/scim/Users Secondary Userstore Command curl -v -k --user admin:admin --data \"{\"schemas\":[],\"userName\":'mysql/uresh67',\"password\":\"Wso2@123\"}\" --header \"Content-Type:application/json\" https://localhost:9443/wso2/scim/Users Note that the user name is preceded by the domain and is within single quotes 'mysql/uresh67'. Also note that 'mysql' here is a reference to a domain name. The above command provides the following results: Primary Userstore Output {\"id\":\"db4f9c15-8426-4381-a669-270975d50421\",\"EnterpriseUser\":{\"organization\":\"WSO2Org\",\"manager\":{\"managerId\":\"111000\",\"displayName\":\"Prabath\"},\"division\":\"Engineering\",\"department\":\"Intigration\",\"costCenter\":\"111111\",\"employeeNumber\":\"73\"},\"schemas\":[\"urn:scim:schemas:core:1.0\",\"urn:scim:schemas:extension:wso2:1.0\"],\"userName\":\"SureshAtt\",\"meta\":{\"lastModified\":\"2013-07-09T13:27:58\",\"location\":\"https://localhost:9443/wso2/scim/Users/db4f9c15-8426-4381-a669-270975d50421\",\"created\":\"2013-07-09T13:27:58\"}} Secondary Userstore Output {\"id\":\"2e89cac0-17f3-40e7-8a07-ff1047a70cf1\",\"schemas\":[\"urn:scim:schemas:core:1.0\"],\"userName\":\"mysql/uresh67\",\"meta\":{\"lastModified\":\"2013-12-17T14:31:30\",\"location\":\"https://localhost:9443/wso2/scim/Users/2e89cac0-17f3-40e7-8a07-ff1047a70cf1\",\"created\":\"2013-12-17T14:31:30\"}}* Closing connection #0 The created SCIM user object can be viewed in the following screen:","title":"cURL commands"},{"location":"get-started/provisioning-architecture/#related-links","text":"See SCIM 1.1 APIs for more cURL commands that can be used to do various functions using the SCIM endpoints available.","title":"Related links"},{"location":"get-started/quick-start-guide/","text":"Quick Start Guide \u00b6 WSO2 Identity Server (WSO2 IS) is a comprehensive identity and access management (IAM) solution. It caters to identity management requirements across many platforms such as enterprise applications, services, and APIs. This guide gives you a quick walk-through to WSO2 IS using a sample scenario. Sample Scenario \u00b6 Pickup is a cab company that has many employees who use different credentials to sign in to different internal enterprise applications. Following are two such applications: Pickup Dispatch : This application helps manage the overall operations at Pickup. Pickup Manager : This application helps allocate vehicles to drivers. Pickup needs to identify the necessary permission levels to be granted to the employees and any security vulnerabilities. Cameron is a senior manager at Pickup who is responsible for resolving these issues using WSO2 IS. Alex is a junior manager attending to day-to-day tasks and Rowan is the HR manager. Let's assume that you are Cameron, and you want to resolve these issues using WSO2 IS. Before you begin \u00b6 Download and install Oracle Java SE Development Kit (JDK) version 1.7.* or 1.8. Install WSO2 IS 5.9.0 by downloading the installer . The WSO2 IS installation location varies according to the OS as given below. OS Home Directory Mac OS /Library/WSO2/IdentityServer/5.7.0 Windows C:\\Program Files\\WSO2\\IdentityServer\\5.7.0 Ubuntu /usr/lib/wso2/IdentityServer/5.7.0 CentOS /usr/lib64/IdentityServer/5.4.70 For the rest of this guide, the installation location of WSO2 IS is referred to as <IS_HOME> . Download and install curl. Make sure you install the binary type file of the version you choose. Open the /etc/hosts file and add the following entry. 127.0.0.1 localhost.com Notes If you are planning to use Single Sign-On (SSO), do not use localhost as it will cause the Tomcat naked host issue. Use localhost.com instead. If you are using Windows, localhost.com is considered as 127.0.0.1 . Make sure that this is the only such entry available for this IP address in the /etc/hosts file to avoid any conflicts. Start WSO2 IS. You are now ready to deploy the sample. Steps to configure and run the samples Download the samples from GitHub and unzip. unzip /home/../is-samples-distribution-4.1.0.zip Note From this point onwards: <IS_HOME> is the directory in which the WSO2 Identity Server is installed. <TOMCAT_HOME> is the directory in which your Apache Tomcat server is installed. Open the server.properties file in <IS_SAMPLE_DISTR>/IS-QSG/conf/ and make sure that wso2is.host.domain and wso2is.host.port are configured as shown below. #localhost.com is used to resolve naked hostname validation issue wso2is.host.domain=localhost.com wso2is.host.port=9443 server.host.domain=localhost.com server.host.port=8080 Navigate to <IS_HOME>/bin using the command prompt and start the server. Linux --> sh wso2server.sh Windows --> wso2server.bat Note that the following appears in the command prompt after the server start. Shutting down the server To shutdown the server, press Ctrl + C . Note that following log appears in the command prompt after the server shutdown. Navigate to /IS-QSG/bin and execute either of the following commands to start the sample application. Linux --> sh app-server.sh Windows --> app-server.bat 8. Navigate to is-samples-2.0.0/IS-QSG/samples / QSG-bundle/QSG/bin and execute either of the following commands to start the Quick Start samples. Linux --> sh qsg.sh Windows --> sh qsg.bat A message appears to pick a scenario, which indicates that the samples are deployed and the WSO2 Identity Server is up and running. When prompted, confirm the configurations. Note that a message appears to pick a scenario, which indicates that the samples are deployed and WSO2 IS is up and running. Let's try out the samples. Single Sign-On \u00b6 Problem Scenario \u00b6 The first problem that Pickup faces is that each employee has to use separate sets of user names and passwords (credentials) to log in to Pickup Dispatch and Pickup Manager. When the number of applications that are used in Pickup increases, the employees have to maintain more credentials. This is not scalable. Cameron decides to use Single Sign-On (SSO) to overcome this situation. With SSO, when a user signs in to one application (authentication), that user is automatically authenticated to other applications, eliminating the need to maintain multiple credentials. Cameron decides to use WSO2 IS to configure SSO. Let's use the command-line to check the SSO functionality with SAML2 or OIDC. Configuring SSO with SAML2 \u00b6 If the two applications are using SAML2 as their authentication protocol, follow the steps below: Enter 1 as the scenario number at the command prompt to: Create the two users, Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Note that a message with the user and web application details appears. Note You can also perform the above using the WSO2 IS Management Console. For more information, see Creating users and roles , Configuring service providers , and Configuring web app for SSO . Go to the URL http://localhost.com:8080/saml2-web-app-pickup-dispatch.com using a web browser to access the Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Senior Manager --> Username: cameron | Password: cameron123 Junior Manager --> Username: alex | Password: alex123 Select the attributes that you want to share with Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of the GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. Similarly, go to the URL http://localhost.com:8080/saml2-web-app-pickup-manager.com Using your browser to access the Pickup Manager application. Click Log in . Note that the Pickup Manager application opens without having to enter the user credentials again. To try out other scenarios, navigate back to where you ran the Quick Start sample on the command-line and enter y to clean the setup. Configuring SSO with OIDC \u00b6 If the two applications are using OIDC as their authentication protocol, follow the steps below: Enter 2 as the scenario number at the command prompt. Create the two users: Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Note that a message with the user and web application details appears. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Pickup Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Senior Manager --> Username: cameron | Password: cameron123 Junior Manager --> Username: alex | Password: alex123 Select the approval type that you wish provide and the attributes that you wish to share with the application and click Continue . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. Similarly, enter http://localhost:8080/pickup-manager on a browser to access the Pickup Manager application. Notice that the Pickup Manager application opens without having to enter the user credentials. You have set up SSO and your employees are happy with their experience as they only have to provide credentials once in order to access both Pickup Dispatch and Pickup Manager. 7. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup. Multi-factor Authentication \u00b6 Problem Scenario \u00b6 Pickup has a secure, hassle-free identity management system in place to better protect the data resources and applications. However, the traditional authentication mechanism that uses a user ID and password is not sufficient. Cameron wants to enhance the security standards by introducing another level of authentication. As a result, Cameron decides to use the Multi-factor Authentication (MFA) capability in WSO2 IS using the following factors: First factor : password Second factor : HARDWARE KEY Let's use the command-line to check the MFA functionality. Configuring Multi-Factor Authentication \u00b6 First deploy the sample authenticator dependency and web application in WSO2 IS. Download the org.wso2.carbon.identity.sample.extension.authenticators-5.7.0.jar file and paste inside the <IS_HOME>/repository/components/dropins directory. Download the sample-auth.war file and paste it inside the <IS_HOME>/repository/deployment/server/webapps folder. This .war file contains the WEB UI for the sample authenticators used in this tutorial. 3.Add the followings to the deployment.toml in /repository/conf [[resource.access_control]] context = \"(. )/sample-auth/(. )\" secure = false http_method = \"all\" And restart the identity server Follow the steps below to configure MFA on the Pickup Dispatch and Pickup Manager applications where HARDWARE KEY is the second authentication factor. Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples / QSG-bundle/QSG/bin using the command-line and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 3 as the scenario number at the command prompt. Enter y to confirm that you have already done the folloing steps. Enter the http://localhost:8080/saml2-web-app-pickup-dispatch.com URL on a web browser to access the Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Manager --> Username: cameron | Password: cameron123 Employee --> Username: alex | Password: alex123 The HARDWARE KEY login page appears as HARDWARE KEY is the second authentication factor. Enter the DEMO key that appears in the browser and click Sign In . After successful authentication, the User Consents form of the Dispatch application appears. Select the attributes that you want to share with Dispatch and click Approve . Note Obtaining user consent is one of the fundamental requirements of the GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Dispatch home screen appears. To try out other scenarios, navigate back to where you ran the Quick Start sample on the command-line and enter y to clean the setup. Federated Authentication \u00b6 Problem Scenario \u00b6 Pickup works with a team of external consultants. Cameron wants to grant them access to the Pickup Dispatch and Pickup Manager applications. However, it is a hassle to keep adding and maintaining their accounts in the employee database as these consultants are temporary and they keep rotating. Therefore, Cameron decides to use the identity federation capability of WSO2 IS. This facilitates the external consultants to use their already existing Google account credentials to sign in to the Pickup applications. Let's use the command line utility to check out how an external consultant uses the command utility to configure federated authentication. Configuring Federated Authentication \u00b6 Follow the steps below to configure federated authentication using WSO2 IS: Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 4 as the scenario number at the command prompt to: Create the two users: Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Register OAuth 2.0 Application in Google. As the first step, go to Google API Console and navigate to the Credentials tab from the sidebar. You can configure OAuth web application in Google by selecting OAuth Client ID . You can find more details from here . Select a web application and give it a name (e.g., SampleWebApllication). Enter the Authorized redirect URI as https://localhost.com:9443/commonauth (this is the endpoint in WSO2 Identity Server that accepts the response sent by Google). Note down the API key and secret for later use. Tip In order to avoid getting the following error message, add localhost.com to the authorized domains list. If Invalid Redirect: domain must be added to the authorized domains list before submitting. Enter y to confirm that you have already registered an app in Google. (See Prerequisites tab) Enter the client-id and the secret of the Google application when prompted. Note that a message with the user and application details appears. Enter the http://localhost:8080/saml2-web-app-pickup-dispatch.com URL on a web browser to access the Pickup Dispatch application. Click Log in . The Twitter login page appears. Enter your Google username and password and click Sign In . After a successful authentication, the User Consents form of the Dispatch application appears. Select the attributes that you wish to share with Pickup Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. You have just signed in to the Pickup Dispatch application as an external consultant using your Twitter credentials. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup. Self Sign-up \u00b6 Problem Scenario \u00b6 Pickup is going through a major expansion and is in the process of hiring new employees. Currently, when a new employee joins, the Pickup HR team requests for their details, and creates user accounts and then asks them to verify, edit and customize their user profiles. This process sometimes takes few days. Thus, the Rowan and the Pickup HR team is having a hard time doing this one by one for especially when a larger number of employees come on-board. Cameron realizes that allowing the new employees to self sign-up to Pickup web applications will speed up the onboarding process. As a result Cameron sets this up for Pickup HR using WSO2 IS. Let's use the command line utility to check out the self sign-up functionality. Configuring Self-Sign-up \u00b6 Follow the steps below to configure self sign-up for Pickup Dispatch and Pickup Manager applications using WSO2 IS. Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Add and configure the following properties in the deployment.toml file found in the <IS_HOME>/repository/conf folder. Update the address, username, and password parameters with the values of a valid email account. [output_adapter.email] from_address = username = password = Restart WSO2 IS. Linux --> sh wso2server.sh Windows --> wso2server.bat Navigate to is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run Enter 5 as the scenario number at the command prompt. A prompt appears to choose the user sign-up approach. Enable self user registration (without any config) : This enables self sign-up without having to do additional configurations. Once registered, the user receives an email to the provided email address. Enable account lock on creation : This locks the user account during user registration. The user can only sign in to the application after clicking the verification link sent to the user-provided email address. A confirmation mail is sent to the user but user account is locked until the user confirms the account by clicking on the account confirmation mail sent by WSO2 IS. 2. Enter number that matches with the approach you would like to try. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Dispatch application. Click Log in . Click Register Now . Enter a username for your user account and click Proceed to Self Register . Note If you want a user to self register for a specific tenant, provide the username in the following format: <USERNAME>@<TENAND_DOMAIN> . Provide the user profile details , agree to the Privacy Policy , and click Register . A confirmation message appears. Click Close . If you selected Enable User Registration (without any config) at step 1 , navigate back to the Pickup Dispatch application and sign in using the new user credentials. If you selected Account Lock on Creation at step 1 , access your email account to view the account registration confirmation mail. Click Confirm Registration in the email or copy the link in the email to your browser and confirm the account creation. The account gets unlocked and an email is sent. Navigate back to the Pickup Dispatch application and sign in using the new user credentials. Note that the Dispatch home screen appears. You have just self-signed up to a Pickup web application. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup. Workflows \u00b6 Problem Scenario \u00b6 After Cameron sets up self registration for Pickup web applications, Rowan is concerned about the security. Rowan prefers to review and approve new user accounts before granting access to the Pickup web applications. Thus, Rowan reaches out to Cameron with these concerns. Cameron realizes the possibility of creating a workflow using WSO2 IS and granting role-based authorization, so that each account registration will be subject to approval. Let's use the command-line to check out the workflow functionality. In this workflow, whenever a new user account is created, first it creates a task for a junior manager (Alex) to approve/reject the account creation. Upon the junior manager approving the account creation, a task will be created for the senior manager (Cameron) to approve or reject the user account. Configuring a Workflow \u00b6 Follow the steps below to configure a workflow. Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples / QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 6 as the scenario number at the command prompt. Note that a message with the user and web application details appears. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Pickup Dispatch application. Click Log in . Click Register Now . Enter a username for your user account and click Proceed to Self Register . Note If you want a user to self register for a specific tenant, provide the username in the following format: <USERNAME>@<TENAND_DOMAIN> . Provide the user profile details , agree to the Privacy Policy , and click Register . Even though a new user account is created successfully, it is in disabled state. To enable the user, you need to sign in to the WSO2 dashboard and approve the pending workflow requests. Enter the http://localhost:9443/dashboard URL on a web browser to access WSO2 Dashboard . Enter the following credentials to sign in as Alex and click Sign In . Username: alex | Password: alex123 Provide the consents. Click Pending Approvals > View Details . Click the Task ID . Click Approve to approve the user account creation. Note that a confirmation message appears. Click OK . Click Sign out to sign out of WSO2 Dashboard as Alex. Enter the following credentials to sign in as Cameron and click Sign In . Username: cameron | Password: cameron123 Provide consents. Click Pending Approvals > View Details . Click the Task ID . Click Approve to approve the user account creation. Navigate back to the Pickup Dispatch application and sign in using the new user credentials. Select the attributes that you wish to share with Pickup Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. This concludes the Quick Start Guide! You have set up WSO2 IS and gone through the basic use cases of the product. For more advanced use cases, check our Tutorials .","title":"Quick Start Guide"},{"location":"get-started/quick-start-guide/#quick-start-guide","text":"WSO2 Identity Server (WSO2 IS) is a comprehensive identity and access management (IAM) solution. It caters to identity management requirements across many platforms such as enterprise applications, services, and APIs. This guide gives you a quick walk-through to WSO2 IS using a sample scenario.","title":"Quick Start Guide"},{"location":"get-started/quick-start-guide/#sample-scenario","text":"Pickup is a cab company that has many employees who use different credentials to sign in to different internal enterprise applications. Following are two such applications: Pickup Dispatch : This application helps manage the overall operations at Pickup. Pickup Manager : This application helps allocate vehicles to drivers. Pickup needs to identify the necessary permission levels to be granted to the employees and any security vulnerabilities. Cameron is a senior manager at Pickup who is responsible for resolving these issues using WSO2 IS. Alex is a junior manager attending to day-to-day tasks and Rowan is the HR manager. Let's assume that you are Cameron, and you want to resolve these issues using WSO2 IS.","title":"Sample Scenario"},{"location":"get-started/quick-start-guide/#before-you-begin","text":"Download and install Oracle Java SE Development Kit (JDK) version 1.7.* or 1.8. Install WSO2 IS 5.9.0 by downloading the installer . The WSO2 IS installation location varies according to the OS as given below. OS Home Directory Mac OS /Library/WSO2/IdentityServer/5.7.0 Windows C:\\Program Files\\WSO2\\IdentityServer\\5.7.0 Ubuntu /usr/lib/wso2/IdentityServer/5.7.0 CentOS /usr/lib64/IdentityServer/5.4.70 For the rest of this guide, the installation location of WSO2 IS is referred to as <IS_HOME> . Download and install curl. Make sure you install the binary type file of the version you choose. Open the /etc/hosts file and add the following entry. 127.0.0.1 localhost.com Notes If you are planning to use Single Sign-On (SSO), do not use localhost as it will cause the Tomcat naked host issue. Use localhost.com instead. If you are using Windows, localhost.com is considered as 127.0.0.1 . Make sure that this is the only such entry available for this IP address in the /etc/hosts file to avoid any conflicts. Start WSO2 IS. You are now ready to deploy the sample. Steps to configure and run the samples Download the samples from GitHub and unzip. unzip /home/../is-samples-distribution-4.1.0.zip Note From this point onwards: <IS_HOME> is the directory in which the WSO2 Identity Server is installed. <TOMCAT_HOME> is the directory in which your Apache Tomcat server is installed. Open the server.properties file in <IS_SAMPLE_DISTR>/IS-QSG/conf/ and make sure that wso2is.host.domain and wso2is.host.port are configured as shown below. #localhost.com is used to resolve naked hostname validation issue wso2is.host.domain=localhost.com wso2is.host.port=9443 server.host.domain=localhost.com server.host.port=8080 Navigate to <IS_HOME>/bin using the command prompt and start the server. Linux --> sh wso2server.sh Windows --> wso2server.bat Note that the following appears in the command prompt after the server start. Shutting down the server To shutdown the server, press Ctrl + C . Note that following log appears in the command prompt after the server shutdown. Navigate to /IS-QSG/bin and execute either of the following commands to start the sample application. Linux --> sh app-server.sh Windows --> app-server.bat 8. Navigate to is-samples-2.0.0/IS-QSG/samples / QSG-bundle/QSG/bin and execute either of the following commands to start the Quick Start samples. Linux --> sh qsg.sh Windows --> sh qsg.bat A message appears to pick a scenario, which indicates that the samples are deployed and the WSO2 Identity Server is up and running. When prompted, confirm the configurations. Note that a message appears to pick a scenario, which indicates that the samples are deployed and WSO2 IS is up and running. Let's try out the samples.","title":"Before you begin"},{"location":"get-started/quick-start-guide/#single-sign-on","text":"","title":"Single Sign-On"},{"location":"get-started/quick-start-guide/#problem-scenario","text":"The first problem that Pickup faces is that each employee has to use separate sets of user names and passwords (credentials) to log in to Pickup Dispatch and Pickup Manager. When the number of applications that are used in Pickup increases, the employees have to maintain more credentials. This is not scalable. Cameron decides to use Single Sign-On (SSO) to overcome this situation. With SSO, when a user signs in to one application (authentication), that user is automatically authenticated to other applications, eliminating the need to maintain multiple credentials. Cameron decides to use WSO2 IS to configure SSO. Let's use the command-line to check the SSO functionality with SAML2 or OIDC.","title":"Problem Scenario"},{"location":"get-started/quick-start-guide/#configuring-sso-with-saml2","text":"If the two applications are using SAML2 as their authentication protocol, follow the steps below: Enter 1 as the scenario number at the command prompt to: Create the two users, Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Note that a message with the user and web application details appears. Note You can also perform the above using the WSO2 IS Management Console. For more information, see Creating users and roles , Configuring service providers , and Configuring web app for SSO . Go to the URL http://localhost.com:8080/saml2-web-app-pickup-dispatch.com using a web browser to access the Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Senior Manager --> Username: cameron | Password: cameron123 Junior Manager --> Username: alex | Password: alex123 Select the attributes that you want to share with Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of the GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. Similarly, go to the URL http://localhost.com:8080/saml2-web-app-pickup-manager.com Using your browser to access the Pickup Manager application. Click Log in . Note that the Pickup Manager application opens without having to enter the user credentials again. To try out other scenarios, navigate back to where you ran the Quick Start sample on the command-line and enter y to clean the setup.","title":"Configuring SSO with SAML2"},{"location":"get-started/quick-start-guide/#configuring-sso-with-oidc","text":"If the two applications are using OIDC as their authentication protocol, follow the steps below: Enter 2 as the scenario number at the command prompt. Create the two users: Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Note that a message with the user and web application details appears. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Pickup Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Senior Manager --> Username: cameron | Password: cameron123 Junior Manager --> Username: alex | Password: alex123 Select the approval type that you wish provide and the attributes that you wish to share with the application and click Continue . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. Similarly, enter http://localhost:8080/pickup-manager on a browser to access the Pickup Manager application. Notice that the Pickup Manager application opens without having to enter the user credentials. You have set up SSO and your employees are happy with their experience as they only have to provide credentials once in order to access both Pickup Dispatch and Pickup Manager. 7. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup.","title":"Configuring SSO with OIDC"},{"location":"get-started/quick-start-guide/#multi-factor-authentication","text":"","title":"Multi-factor Authentication"},{"location":"get-started/quick-start-guide/#problem-scenario_1","text":"Pickup has a secure, hassle-free identity management system in place to better protect the data resources and applications. However, the traditional authentication mechanism that uses a user ID and password is not sufficient. Cameron wants to enhance the security standards by introducing another level of authentication. As a result, Cameron decides to use the Multi-factor Authentication (MFA) capability in WSO2 IS using the following factors: First factor : password Second factor : HARDWARE KEY Let's use the command-line to check the MFA functionality.","title":"Problem Scenario"},{"location":"get-started/quick-start-guide/#configuring-multi-factor-authentication","text":"First deploy the sample authenticator dependency and web application in WSO2 IS. Download the org.wso2.carbon.identity.sample.extension.authenticators-5.7.0.jar file and paste inside the <IS_HOME>/repository/components/dropins directory. Download the sample-auth.war file and paste it inside the <IS_HOME>/repository/deployment/server/webapps folder. This .war file contains the WEB UI for the sample authenticators used in this tutorial. 3.Add the followings to the deployment.toml in /repository/conf [[resource.access_control]] context = \"(. )/sample-auth/(. )\" secure = false http_method = \"all\" And restart the identity server Follow the steps below to configure MFA on the Pickup Dispatch and Pickup Manager applications where HARDWARE KEY is the second authentication factor. Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples / QSG-bundle/QSG/bin using the command-line and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 3 as the scenario number at the command prompt. Enter y to confirm that you have already done the folloing steps. Enter the http://localhost:8080/saml2-web-app-pickup-dispatch.com URL on a web browser to access the Dispatch application. Click Log in . Enter either of the following credentials to sign in to the application. Manager --> Username: cameron | Password: cameron123 Employee --> Username: alex | Password: alex123 The HARDWARE KEY login page appears as HARDWARE KEY is the second authentication factor. Enter the DEMO key that appears in the browser and click Sign In . After successful authentication, the User Consents form of the Dispatch application appears. Select the attributes that you want to share with Dispatch and click Approve . Note Obtaining user consent is one of the fundamental requirements of the GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Dispatch home screen appears. To try out other scenarios, navigate back to where you ran the Quick Start sample on the command-line and enter y to clean the setup.","title":"Configuring Multi-Factor Authentication"},{"location":"get-started/quick-start-guide/#federated-authentication","text":"","title":"Federated Authentication"},{"location":"get-started/quick-start-guide/#problem-scenario_2","text":"Pickup works with a team of external consultants. Cameron wants to grant them access to the Pickup Dispatch and Pickup Manager applications. However, it is a hassle to keep adding and maintaining their accounts in the employee database as these consultants are temporary and they keep rotating. Therefore, Cameron decides to use the identity federation capability of WSO2 IS. This facilitates the external consultants to use their already existing Google account credentials to sign in to the Pickup applications. Let's use the command line utility to check out how an external consultant uses the command utility to configure federated authentication.","title":"Problem Scenario"},{"location":"get-started/quick-start-guide/#configuring-federated-authentication","text":"Follow the steps below to configure federated authentication using WSO2 IS: Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 4 as the scenario number at the command prompt to: Create the two users: Cameron and Alex. Create and assign the user role Manager to Cameron. Create service providers for Pickup Dispatch and Pickup Manager. Configure SAML2 web SSO for Pickup Dispatch and Pickup Manager. Register OAuth 2.0 Application in Google. As the first step, go to Google API Console and navigate to the Credentials tab from the sidebar. You can configure OAuth web application in Google by selecting OAuth Client ID . You can find more details from here . Select a web application and give it a name (e.g., SampleWebApllication). Enter the Authorized redirect URI as https://localhost.com:9443/commonauth (this is the endpoint in WSO2 Identity Server that accepts the response sent by Google). Note down the API key and secret for later use. Tip In order to avoid getting the following error message, add localhost.com to the authorized domains list. If Invalid Redirect: domain must be added to the authorized domains list before submitting. Enter y to confirm that you have already registered an app in Google. (See Prerequisites tab) Enter the client-id and the secret of the Google application when prompted. Note that a message with the user and application details appears. Enter the http://localhost:8080/saml2-web-app-pickup-dispatch.com URL on a web browser to access the Pickup Dispatch application. Click Log in . The Twitter login page appears. Enter your Google username and password and click Sign In . After a successful authentication, the User Consents form of the Dispatch application appears. Select the attributes that you wish to share with Pickup Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. You have just signed in to the Pickup Dispatch application as an external consultant using your Twitter credentials. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup.","title":"Configuring Federated Authentication"},{"location":"get-started/quick-start-guide/#self-sign-up","text":"","title":"Self Sign-up"},{"location":"get-started/quick-start-guide/#problem-scenario_3","text":"Pickup is going through a major expansion and is in the process of hiring new employees. Currently, when a new employee joins, the Pickup HR team requests for their details, and creates user accounts and then asks them to verify, edit and customize their user profiles. This process sometimes takes few days. Thus, the Rowan and the Pickup HR team is having a hard time doing this one by one for especially when a larger number of employees come on-board. Cameron realizes that allowing the new employees to self sign-up to Pickup web applications will speed up the onboarding process. As a result Cameron sets this up for Pickup HR using WSO2 IS. Let's use the command line utility to check out the self sign-up functionality.","title":"Problem Scenario"},{"location":"get-started/quick-start-guide/#configuring-self-sign-up","text":"Follow the steps below to configure self sign-up for Pickup Dispatch and Pickup Manager applications using WSO2 IS. Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Add and configure the following properties in the deployment.toml file found in the <IS_HOME>/repository/conf folder. Update the address, username, and password parameters with the values of a valid email account. [output_adapter.email] from_address = username = password = Restart WSO2 IS. Linux --> sh wso2server.sh Windows --> wso2server.bat Navigate to is-samples-1.0.0/IS-QSG/samples/QSG-bundle/QSG/bin and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run Enter 5 as the scenario number at the command prompt. A prompt appears to choose the user sign-up approach. Enable self user registration (without any config) : This enables self sign-up without having to do additional configurations. Once registered, the user receives an email to the provided email address. Enable account lock on creation : This locks the user account during user registration. The user can only sign in to the application after clicking the verification link sent to the user-provided email address. A confirmation mail is sent to the user but user account is locked until the user confirms the account by clicking on the account confirmation mail sent by WSO2 IS. 2. Enter number that matches with the approach you would like to try. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Dispatch application. Click Log in . Click Register Now . Enter a username for your user account and click Proceed to Self Register . Note If you want a user to self register for a specific tenant, provide the username in the following format: <USERNAME>@<TENAND_DOMAIN> . Provide the user profile details , agree to the Privacy Policy , and click Register . A confirmation message appears. Click Close . If you selected Enable User Registration (without any config) at step 1 , navigate back to the Pickup Dispatch application and sign in using the new user credentials. If you selected Account Lock on Creation at step 1 , access your email account to view the account registration confirmation mail. Click Confirm Registration in the email or copy the link in the email to your browser and confirm the account creation. The account gets unlocked and an email is sent. Navigate back to the Pickup Dispatch application and sign in using the new user credentials. Note that the Dispatch home screen appears. You have just self-signed up to a Pickup web application. Next, in order to try out other scenarios, navigate back to the command prompt where you ran the Quick Start sample and enter y to clean the setup.","title":"Configuring Self-Sign-up"},{"location":"get-started/quick-start-guide/#workflows","text":"","title":"Workflows"},{"location":"get-started/quick-start-guide/#problem-scenario_4","text":"After Cameron sets up self registration for Pickup web applications, Rowan is concerned about the security. Rowan prefers to review and approve new user accounts before granting access to the Pickup web applications. Thus, Rowan reaches out to Cameron with these concerns. Cameron realizes the possibility of creating a workflow using WSO2 IS and granting role-based authorization, so that each account registration will be subject to approval. Let's use the command-line to check out the workflow functionality. In this workflow, whenever a new user account is created, first it creates a task for a junior manager (Alex) to approve/reject the account creation. Upon the junior manager approving the account creation, a task will be created for the senior manager (Cameron) to approve or reject the user account.","title":"Problem Scenario"},{"location":"get-started/quick-start-guide/#configuring-a-workflow","text":"Follow the steps below to configure a workflow. Tip Before you begin If you have run any other samples in this Quick Start Guide, navigate back to the is-samples-1.0.0/IS-QSG/samples / QSG-bundle/QSG/bin on the command prompt and execute either of the following commands to start the Quick Start samples. Linux --> sudo sh qsg.sh run Windows --> sudo qsg.bat run A message appears to pick a scenario. Enter 6 as the scenario number at the command prompt. Note that a message with the user and web application details appears. Enter the http://localhost.com:8080/pickup-dispatch URL on a web browser to access the Pickup Dispatch application. Click Log in . Click Register Now . Enter a username for your user account and click Proceed to Self Register . Note If you want a user to self register for a specific tenant, provide the username in the following format: <USERNAME>@<TENAND_DOMAIN> . Provide the user profile details , agree to the Privacy Policy , and click Register . Even though a new user account is created successfully, it is in disabled state. To enable the user, you need to sign in to the WSO2 dashboard and approve the pending workflow requests. Enter the http://localhost:9443/dashboard URL on a web browser to access WSO2 Dashboard . Enter the following credentials to sign in as Alex and click Sign In . Username: alex | Password: alex123 Provide the consents. Click Pending Approvals > View Details . Click the Task ID . Click Approve to approve the user account creation. Note that a confirmation message appears. Click OK . Click Sign out to sign out of WSO2 Dashboard as Alex. Enter the following credentials to sign in as Cameron and click Sign In . Username: cameron | Password: cameron123 Provide consents. Click Pending Approvals > View Details . Click the Task ID . Click Approve to approve the user account creation. Navigate back to the Pickup Dispatch application and sign in using the new user credentials. Select the attributes that you wish to share with Pickup Dispatch and click Approve . Note Obtaining the user consent is one of the fundamental requirements of GDPR regulation. WSO2 IS facilitates this through its Consent Management features. To know more about GDPR and how WSO2 IS handles consent, see Consent Management . Note that the Pickup Dispatch home screen appears. This concludes the Quick Start Guide! You have set up WSO2 IS and gone through the basic use cases of the product. For more advanced use cases, check our Tutorials .","title":"Configuring a Workflow"},{"location":"get-started/single-sign-on-and-identity-federation/","text":"Single Sign-On and Identity Federation \u00b6 Introducing single sign-on \u00b6 Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable. How single sign-on works \u00b6 To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works. SSO in reality \u00b6 Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and returned immediately to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password. Supported protocols for SSO \u00b6 The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them. SAML 2.0 SSO \u00b6 SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances SAML 2.0 web browser-based SSO profile \u00b6 SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . Click here for more information on assertion consumers, the authentication request and response SAML 2.0 SSO assertion consumers Service providers act as SAML assertion consumers. They have two basic functions: Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer(); public void doGet(HttpServletRequest request, HttpServletResponse response) { requestMessage = consumer.buildRequestMessage(); response.sendRedirect(requestMessage); } public void doPost(HttpServletRequest request, HttpServletResponse response) { responseMessage = request.getParameter(\"SAMLResponse\").toString(); result = consumer.processResponseMessage(responseMessage); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing. AuthnRequest message To create an <AuthnRequest> message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample <AuthnRequest> message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. String issuerId = \"saml2.sso.demo\"; IssuerBuilder issuerBuilder = new IssuerBuilder(); Issuer issuer = issuerBuilder.buildObject(\"urn:oasis:names:tc:SAML: 2.0:assertion\", \"Issuer\", \"samlp\"); issuer.setValue(issuerId); Create the <AuthnRequest> next. // the issuerUrl is the url of the service provider who generates the message String issuerUrl = \"http://localhost:8080/saml2.sso.demo/consumer\"; DateTime issueInstant = new DateTime(); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder(); AuthnRequest authnRequest = authnRequestBuilder.buildObject(\"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\", \"samlp\"); authnRequest.setForceAuthn(false); authnRequest.setIsPassive(false); authnRequest.setIssueInstant(issueInstant); authnRequest.setProtocolBinding(\"urn:oasis:names:tc:SAML: 2.0:bindings:HTTP-POST\"); authnRequest.setAssertionConsumerServiceURL(issuerUrl); authnRequest.setIssuer(issuer); authnRequest.setID(aRandomId); authnRequest.setVersion(SAMLVersion.VERSION_20); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. Marshaller marshaller = Configuration.getMarshallerFactory().getMarshaller(authnRequest); Element authDOM = marshaller.marshall(authnRequest); StringWriter rspWrt = new StringWriter(); XMLHelper.writeNode(authDOM, rspWrt); String requestMessage = rspWrt.toString(); Deflater deflater = new Deflater(Deflater.DEFLATED, true); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater); deflaterOutputStream.write(requestMessage.getBytes()); deflaterOutputStream.close(); /* Encoding the compressed message */ String encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream.toByteArray(), Base64.DONT_BREAK_LINES); String encodedAuthnRequest = URLEncoder.encode(encodedRequestMessage,\"UTF-8\").trim(); Construct the redirection URL. redirectionUrl = identitypProviderUrl+ \"?SAMLRequest=\" + encodedRequestMessage; Redirect the user to the identity provider. response.sendRedirect(redirectionUrl); Response message The Identity provider must use HTTP POST or artifact binding to transfer the <SAMLResponse> message to the service provider. To read the <Response> message issued by the WSO2 Identity Server, do the following: A sample < Response > message can be found here . The response message must be fetched from the request. responseMessage = request.getParameter(\"SAMLResponse\").toString(); The fetched responseMessage is unmarshaled and the SAML message is retrieved. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setNamespaceAware(true); DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder(); byte[] base64DecodedResponse = Base64.decode(responseMessage); ByteArrayInputStream is = new ByteArrayInputStream(base64DecodedResponse); Document document = docBuilder.parse(is); Element element = document.getDocumentElement(); UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory(); Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element); Response response = (Response) unmarshaller.unmarshall(element); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . String subject = response.getAssertions().get(0).getSubject().getNameID().getValue(); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. String certificate = response.getSignature().getKeyInfo().getX509Datas().get(0).getX509Certificates().get(0).getValue(); Identity provider initiated SSO \u00b6 To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com&RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Info Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information. WS-Federation \u00b6 WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information. OpenID Connect \u00b6 OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information. WS-Trust \u00b6 The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server. Identity federation and a comparison with SSO \u00b6 Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated.","title":"Single Sign-On and Identity Federation"},{"location":"get-started/single-sign-on-and-identity-federation/#single-sign-on-and-identity-federation","text":"","title":"Single Sign-On and Identity Federation"},{"location":"get-started/single-sign-on-and-identity-federation/#introducing-single-sign-on","text":"Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable.","title":"Introducing single sign-on"},{"location":"get-started/single-sign-on-and-identity-federation/#how-single-sign-on-works","text":"To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works.","title":"How single sign-on works"},{"location":"get-started/single-sign-on-and-identity-federation/#sso-in-reality","text":"Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and returned immediately to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password.","title":"SSO in reality"},{"location":"get-started/single-sign-on-and-identity-federation/#supported-protocols-for-sso","text":"The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them.","title":"Supported protocols for SSO"},{"location":"get-started/single-sign-on-and-identity-federation/#saml-20-sso","text":"SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances","title":"SAML 2.0 SSO"},{"location":"get-started/single-sign-on-and-identity-federation/#saml-20-web-browser-based-sso-profile","text":"SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . Click here for more information on assertion consumers, the authentication request and response SAML 2.0 SSO assertion consumers Service providers act as SAML assertion consumers. They have two basic functions: Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer(); public void doGet(HttpServletRequest request, HttpServletResponse response) { requestMessage = consumer.buildRequestMessage(); response.sendRedirect(requestMessage); } public void doPost(HttpServletRequest request, HttpServletResponse response) { responseMessage = request.getParameter(\"SAMLResponse\").toString(); result = consumer.processResponseMessage(responseMessage); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing. AuthnRequest message To create an <AuthnRequest> message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample <AuthnRequest> message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. String issuerId = \"saml2.sso.demo\"; IssuerBuilder issuerBuilder = new IssuerBuilder(); Issuer issuer = issuerBuilder.buildObject(\"urn:oasis:names:tc:SAML: 2.0:assertion\", \"Issuer\", \"samlp\"); issuer.setValue(issuerId); Create the <AuthnRequest> next. // the issuerUrl is the url of the service provider who generates the message String issuerUrl = \"http://localhost:8080/saml2.sso.demo/consumer\"; DateTime issueInstant = new DateTime(); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder(); AuthnRequest authnRequest = authnRequestBuilder.buildObject(\"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\", \"samlp\"); authnRequest.setForceAuthn(false); authnRequest.setIsPassive(false); authnRequest.setIssueInstant(issueInstant); authnRequest.setProtocolBinding(\"urn:oasis:names:tc:SAML: 2.0:bindings:HTTP-POST\"); authnRequest.setAssertionConsumerServiceURL(issuerUrl); authnRequest.setIssuer(issuer); authnRequest.setID(aRandomId); authnRequest.setVersion(SAMLVersion.VERSION_20); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. Marshaller marshaller = Configuration.getMarshallerFactory().getMarshaller(authnRequest); Element authDOM = marshaller.marshall(authnRequest); StringWriter rspWrt = new StringWriter(); XMLHelper.writeNode(authDOM, rspWrt); String requestMessage = rspWrt.toString(); Deflater deflater = new Deflater(Deflater.DEFLATED, true); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater); deflaterOutputStream.write(requestMessage.getBytes()); deflaterOutputStream.close(); /* Encoding the compressed message */ String encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream.toByteArray(), Base64.DONT_BREAK_LINES); String encodedAuthnRequest = URLEncoder.encode(encodedRequestMessage,\"UTF-8\").trim(); Construct the redirection URL. redirectionUrl = identitypProviderUrl+ \"?SAMLRequest=\" + encodedRequestMessage; Redirect the user to the identity provider. response.sendRedirect(redirectionUrl); Response message The Identity provider must use HTTP POST or artifact binding to transfer the <SAMLResponse> message to the service provider. To read the <Response> message issued by the WSO2 Identity Server, do the following: A sample < Response > message can be found here . The response message must be fetched from the request. responseMessage = request.getParameter(\"SAMLResponse\").toString(); The fetched responseMessage is unmarshaled and the SAML message is retrieved. DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setNamespaceAware(true); DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder(); byte[] base64DecodedResponse = Base64.decode(responseMessage); ByteArrayInputStream is = new ByteArrayInputStream(base64DecodedResponse); Document document = docBuilder.parse(is); Element element = document.getDocumentElement(); UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory(); Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element); Response response = (Response) unmarshaller.unmarshall(element); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . String subject = response.getAssertions().get(0).getSubject().getNameID().getValue(); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. String certificate = response.getSignature().getKeyInfo().getX509Datas().get(0).getX509Certificates().get(0).getValue();","title":"SAML 2.0 web browser-based SSO profile"},{"location":"get-started/single-sign-on-and-identity-federation/#identity-provider-initiated-sso","text":"To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com&RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Info Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information.","title":"Identity provider initiated SSO"},{"location":"get-started/single-sign-on-and-identity-federation/#ws-federation","text":"WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information.","title":"WS-Federation"},{"location":"get-started/single-sign-on-and-identity-federation/#openid-connect","text":"OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information.","title":"OpenID Connect"},{"location":"get-started/single-sign-on-and-identity-federation/#ws-trust","text":"The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server.","title":"WS-Trust"},{"location":"get-started/single-sign-on-and-identity-federation/#identity-federation-and-a-comparison-with-sso","text":"Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated.","title":"Identity federation and a comparison with SSO"},{"location":"get-started/user-management-architecture/","text":"User Management Architecture \u00b6 User management functionality is provided by default in all WSO2 Carbon-based products and is configured in the <PRODUCT_HOME>/repository/conf/user-mgt.xml file. The following documentation introduces the main concepts in User Management, such as users, roles, permissions, user stores etc. and how they are used in WSO2 products. User management involves defining and managing users, roles, and their access levels in a system. A user management dashboard or console provides system administrators with a high-level view of a system's active user sessions, their log-in statuses, the privileges of each user, and their activity in the system, enabling system admins to make business-critical, real-time security decisions. A typical user management implementation involves a wide range of functionality such as adding/deleting users, controlling user activity through permissions, managing user roles, defining authentication policies, managing external user stores, manual/automatic log-out, and resetting user passwords. Any user management system has the following basic components: Users: Users are consumers who interact with your organizational applications, databases, and other systems. A user can be a person, a device, or another application/program within or outside of the organization's network. Because users interact with internal systems and access data, security-conscious organizations need to define which data and functionality each user can access by assigning permissions. Permissions: A permission is a delegation of authority or a right that is assigned to a user or a group of users to perform an action on a system. Permissions can be granted to or revoked from a user, user group, or user role automatically or by a system administrator. For example, if a user has the permission to log in to a system, the permission to log out is automatically granted as well. User roles: A user role is a grouping of permissions. In addition to assigning individual permissions to users, admins can create user roles and assign those roles to users. For example, you might create user roles called VP, Manager, and Employee, each of which has a different set of permissions, and then assign those roles to users based on their position in the company. Then, if you need to modify the permissions of all your managers, you can simply modify the Manager user role, and all users with that role will have their permissions updated automatically. The following diagram illustrates how the user management functionality is structured to work in WSO2 products: User stores: A user store is the database where information about the users and user roles is stored, including log-in name, password, first name, last name, and e-mail address. RDBMS (for Authentication and Authorization): This RDBMS stores information of the role-based permissions. Info According to the default configuration in WSO2 products, the embedded H2 RDBMS that is shipped with the product is used as the user store as well as the RDBMS for storing information related to permissions. Realm configuration: The user realm consists of the configurations required to initialise the user realm. The user-mgt.xml file stored in the <PRODUCT_HOME>/repository/conf/ directory is used as the realm configuration XML. This includes setting up the User Store Manager , the Authorization Manager and the System Administrator . These configurations are explained below. User Store Manager The User Store Manager is responsible for managing the underlying user store. It is represented by the UserStoreManager Java interface. There can be different User Store Manager implementations to connect with different user stores, but you can configure only one User Store Manager implementation in a single user realm (that is, a single WSO2 Carbon instance). The User Store Manager can be operated in both read/write mode and read-only mode. In read-only mode, you can only connect with an existing user store. WSO2 products provide the following default User Store Manager implementations: JDBCUserStoreManager (read and write) LDAPUserStoreManager (read-only) ApacheDSUserStoreManager (read and write) You can write a custom user store manager implementation by implementing UserStoreManager or by extending AbstractUserStoreManager or one of the default implementations. Using JDBCUserStoreManager The JDBCUserStoreManager class uses a schema that is specific to WSO2 Carbon. It contains the following tables: UM_USER: Contains user names and passwords UM_ROLE: Contains role names UM_USER_ROLE: Contains user role mappings UM_USER_ATTRIBUTE: Contains user attributes. There can be any attribute ID and a value for that attribute ID that is associated with a user\u2019s profile. You can find the full schema of these tables from the database script files in the <PRODUCT_HOME>/dbscripts directory. Note that these scripts also contain schemas for other tables that are used for user management and registry functions. If your organization contains an existing JDBC user store that you want to use with a WSO2 product, you must extend JDBCUserStoreManager and write a new implementation for your user store according to your schema. Authorization Manager The Authorization Manager uses role-based access control (RBAC) to protect resources related to the WSO2 Carbon platform. The default implementation of the Authorization Manager is JDBCAuthorizationManager , which uses a permission model specific to WSO2 Carbon and uses the authorization data that is stored in tables in the JDBC database. You can replace this implementation with a custom implementation (for example, if you want to use a XACML authorization manager) and use it with WSO2 products. System Administrator The system admin user is typically the super tenant user, who by default has permission to perform all administration tasks in the server. The admin user will thereby create other tenant users and define roles with permissions. Once this is done, the other tenant users will be able to log in to their respective tenant domains and use the server according to the permissions that have been granted. Note that the permissions granted to the Super Tenant user cannot be modified. Related Topics \u00b6 Configuring the Realm : The topics in this section explain how you can set up and configure the user management realm. Configuring Users, Roles and Permissions : The topics in this section explain how you can manage the Users, Roles and Permissions using the management console. Engaging a Workflow in an Operation : This topic explains how to engage workflows for user-related operations.","title":"User Management Architecture"},{"location":"get-started/user-management-architecture/#user-management-architecture","text":"User management functionality is provided by default in all WSO2 Carbon-based products and is configured in the <PRODUCT_HOME>/repository/conf/user-mgt.xml file. The following documentation introduces the main concepts in User Management, such as users, roles, permissions, user stores etc. and how they are used in WSO2 products. User management involves defining and managing users, roles, and their access levels in a system. A user management dashboard or console provides system administrators with a high-level view of a system's active user sessions, their log-in statuses, the privileges of each user, and their activity in the system, enabling system admins to make business-critical, real-time security decisions. A typical user management implementation involves a wide range of functionality such as adding/deleting users, controlling user activity through permissions, managing user roles, defining authentication policies, managing external user stores, manual/automatic log-out, and resetting user passwords. Any user management system has the following basic components: Users: Users are consumers who interact with your organizational applications, databases, and other systems. A user can be a person, a device, or another application/program within or outside of the organization's network. Because users interact with internal systems and access data, security-conscious organizations need to define which data and functionality each user can access by assigning permissions. Permissions: A permission is a delegation of authority or a right that is assigned to a user or a group of users to perform an action on a system. Permissions can be granted to or revoked from a user, user group, or user role automatically or by a system administrator. For example, if a user has the permission to log in to a system, the permission to log out is automatically granted as well. User roles: A user role is a grouping of permissions. In addition to assigning individual permissions to users, admins can create user roles and assign those roles to users. For example, you might create user roles called VP, Manager, and Employee, each of which has a different set of permissions, and then assign those roles to users based on their position in the company. Then, if you need to modify the permissions of all your managers, you can simply modify the Manager user role, and all users with that role will have their permissions updated automatically. The following diagram illustrates how the user management functionality is structured to work in WSO2 products: User stores: A user store is the database where information about the users and user roles is stored, including log-in name, password, first name, last name, and e-mail address. RDBMS (for Authentication and Authorization): This RDBMS stores information of the role-based permissions. Info According to the default configuration in WSO2 products, the embedded H2 RDBMS that is shipped with the product is used as the user store as well as the RDBMS for storing information related to permissions. Realm configuration: The user realm consists of the configurations required to initialise the user realm. The user-mgt.xml file stored in the <PRODUCT_HOME>/repository/conf/ directory is used as the realm configuration XML. This includes setting up the User Store Manager , the Authorization Manager and the System Administrator . These configurations are explained below. User Store Manager The User Store Manager is responsible for managing the underlying user store. It is represented by the UserStoreManager Java interface. There can be different User Store Manager implementations to connect with different user stores, but you can configure only one User Store Manager implementation in a single user realm (that is, a single WSO2 Carbon instance). The User Store Manager can be operated in both read/write mode and read-only mode. In read-only mode, you can only connect with an existing user store. WSO2 products provide the following default User Store Manager implementations: JDBCUserStoreManager (read and write) LDAPUserStoreManager (read-only) ApacheDSUserStoreManager (read and write) You can write a custom user store manager implementation by implementing UserStoreManager or by extending AbstractUserStoreManager or one of the default implementations.","title":"User Management Architecture"},{"location":"get-started/user-management-architecture/#related-topics","text":"Configuring the Realm : The topics in this section explain how you can set up and configure the user management realm. Configuring Users, Roles and Permissions : The topics in this section explain how you can manage the Users, Roles and Permissions using the management console. Engaging a Workflow in an Operation : This topic explains how to engage workflows for user-related operations.","title":"Related Topics"}]}